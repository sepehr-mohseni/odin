
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>testutil: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">odin/cmd/testutil/main.go (0.0%)</option>
				
				<option value="file1">odin/pkg/admin/admin.go (0.0%)</option>
				
				<option value="file2">odin/pkg/admin/auth.go (0.0%)</option>
				
				<option value="file3">odin/pkg/admin/routes.go (0.0%)</option>
				
				<option value="file4">odin/pkg/admin/services.go (0.0%)</option>
				
				<option value="file5">odin/pkg/admin/templates.go (0.0%)</option>
				
				<option value="file6">odin/pkg/auth/jwt.go (0.0%)</option>
				
				<option value="file7">odin/pkg/auth/oauth2.go (0.0%)</option>
				
				<option value="file8">odin/pkg/cache/store.go (0.0%)</option>
				
				<option value="file9">odin/pkg/cache/strategies.go (0.0%)</option>
				
				<option value="file10">odin/pkg/circuit/breaker.go (0.0%)</option>
				
				<option value="file11">odin/pkg/config/config.go (0.0%)</option>
				
				<option value="file12">odin/pkg/debug/debug.go (0.0%)</option>
				
				<option value="file13">odin/pkg/errors/errors.go (0.0%)</option>
				
				<option value="file14">odin/pkg/health/health.go (0.0%)</option>
				
				<option value="file15">odin/pkg/logging/logger.go (0.0%)</option>
				
				<option value="file16">odin/pkg/middleware/logger.go (0.0%)</option>
				
				<option value="file17">odin/pkg/middleware/middleware.go (0.0%)</option>
				
				<option value="file18">odin/pkg/monitoring/prometheus.go (0.0%)</option>
				
				<option value="file19">odin/pkg/ratelimit/limiter.go (0.0%)</option>
				
				<option value="file20">odin/pkg/routing/handler.go (0.0%)</option>
				
				<option value="file21">odin/pkg/routing/router.go (0.0%)</option>
				
				<option value="file22">odin/pkg/service/loader.go (0.0%)</option>
				
				<option value="file23">odin/pkg/service/service.go (0.0%)</option>
				
				<option value="file24">odin/pkg/utils/http.go (0.0%)</option>
				
				<option value="file25">odin/pkg/utils/jsonpath.go (0.0%)</option>
				
				<option value="file26">odin/pkg/websocket/proxy.go (0.0%)</option>
				
				<option value="file27">odin/test/auth/jwt-generator.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "io"
        "net/http"
        "os"
        "time"
)

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Println("Usage: go run main.go &lt;url&gt; [auth_token]")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">url := os.Args[1]
        var token string
        if len(os.Args) &gt; 2 </span><span class="cov0" title="0">{
                token = os.Args[2]
        }</span>

        <span class="cov0" title="0">fmt.Printf("Testing URL: %s\n", url)

        client := &amp;http.Client{
                Timeout: 5 * time.Second,
        }

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error creating request: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if token != "" </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", fmt.Sprintf("Bearer %s", token))
        }</span>

        <span class="cov0" title="0">resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error making request: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error reading response: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Status: %d\n", resp.StatusCode)
        fmt.Printf("Headers: %v\n", resp.Header)
        fmt.Printf("Body: %s\n", string(body))</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package admin

import (
        "odin/pkg/config"
        "os"
        "path/filepath"

        "github.com/sirupsen/logrus"
        "gopkg.in/yaml.v3"
)

type AdminCredentials struct {
        Username string `yaml:"username"`
        Password string `yaml:"password"`
}

type AdminHandler struct {
        config     *config.Config
        configPath string
        logger     *logrus.Logger
        username   string
        password   string
        enabled    bool
}

func loadAdminCredentials(logger *logrus.Logger) (*AdminCredentials, error) <span class="cov0" title="0">{
        credsPaths := []string{
                "config/admin_creds.yaml",
                "/etc/odin/admin_creds.yaml",
                filepath.Join(os.Getenv("HOME"), ".odin", "admin_creds.yaml"),
        }

        var credentials AdminCredentials
        var loaded bool

        for _, path := range credsPaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        data, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                logger.WithError(err).Warnf("Failed to read admin credentials file: %s", path)
                                continue</span>
                        }

                        <span class="cov0" title="0">if err := yaml.Unmarshal(data, &amp;credentials); err != nil </span><span class="cov0" title="0">{
                                logger.WithError(err).Warnf("Failed to parse admin credentials file: %s", path)
                                continue</span>
                        }

                        <span class="cov0" title="0">logger.Infof("Loaded admin credentials from %s", path)
                        loaded = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !loaded </span><span class="cov0" title="0">{
                logger.Warn("No admin credentials file found, will use credentials from main config")
                return nil, nil
        }</span>

        <span class="cov0" title="0">return &amp;credentials, nil</span>
}

func New(cfg *config.Config, configPath string, logger *logrus.Logger) *AdminHandler <span class="cov0" title="0">{
        creds, _ := loadAdminCredentials(logger)

        username := ""
        if creds != nil &amp;&amp; creds.Username != "" </span><span class="cov0" title="0">{
                username = creds.Username
        }</span> else<span class="cov0" title="0"> {
                username = cfg.Admin.Username
        }</span>

        <span class="cov0" title="0">if username == "" </span><span class="cov0" title="0">{
                username = "admin"
        }</span>

        <span class="cov0" title="0">password := ""
        if creds != nil &amp;&amp; creds.Password != "" </span><span class="cov0" title="0">{
                password = creds.Password
        }</span> else<span class="cov0" title="0"> {
                password = cfg.Admin.Password
        }</span>

        <span class="cov0" title="0">if password == "" </span><span class="cov0" title="0">{
                password = "admin1"
        }</span>

        <span class="cov0" title="0">return &amp;AdminHandler{
                config:     cfg,
                configPath: configPath,
                logger:     logger,
                username:   username,
                password:   password,
                enabled:    cfg.Admin.Enabled,
        }</span>
}

func (h *AdminHandler) saveConfig() error <span class="cov0" title="0">{
        data, err := yaml.Marshal(h.config)
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).Error("Failed to marshal configuration")
                return err
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(h.configPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).Error("Failed to write configuration file")
                return err
        }</span>

        <span class="cov0" title="0">h.logger.Info("Configuration saved successfully")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package admin

import (
        "encoding/base64"
        "net/http"
        "strings"

        "github.com/labstack/echo/v4"
)

func (h *AdminHandler) basicAuthMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                if !h.enabled </span><span class="cov0" title="0">{
                        return next(c)
                }</span>

                <span class="cov0" title="0">auth := c.Request().Header.Get("Authorization")

                if auth == "" </span><span class="cov0" title="0">{
                        cookie, err := c.Cookie("Authorization")
                        if err == nil &amp;&amp; cookie.Value != "" </span><span class="cov0" title="0">{
                                auth = cookie.Value
                                if !strings.HasPrefix(auth, "Basic ") </span><span class="cov0" title="0">{
                                        auth = "Basic " + auth
                                }</span>
                        }
                }

                <span class="cov0" title="0">if auth == "" </span><span class="cov0" title="0">{
                        return h.unauthorized(c)
                }</span>

                <span class="cov0" title="0">const basicAuthPrefix = "Basic "
                if !strings.HasPrefix(auth, basicAuthPrefix) </span><span class="cov0" title="0">{
                        return h.unauthorized(c)
                }</span>

                <span class="cov0" title="0">payload, err := base64.StdEncoding.DecodeString(auth[len(basicAuthPrefix):])
                if err != nil </span><span class="cov0" title="0">{
                        return h.unauthorized(c)
                }</span>

                <span class="cov0" title="0">pair := strings.SplitN(string(payload), ":", 2)
                if len(pair) != 2 || pair[0] != h.username || pair[1] != h.password </span><span class="cov0" title="0">{
                        return h.unauthorized(c)
                }</span>

                <span class="cov0" title="0">return next(c)</span>
        }
}

func (h *AdminHandler) unauthorized(c echo.Context) error <span class="cov0" title="0">{
        c.Response().Header().Set("WWW-Authenticate", `Basic realm="Admin Area"`)
        return c.HTML(http.StatusUnauthorized, `
                &lt;html&gt;
                &lt;head&gt;&lt;title&gt;Authentication Required&lt;/title&gt;&lt;/head&gt;
                &lt;body&gt;
                        &lt;h1&gt;Authentication Required&lt;/h1&gt;
                        &lt;p&gt;Please login with admin credentials.&lt;/p&gt;
                        &lt;script&gt;
                                window.location.href = "/admin/login";
                        &lt;/script&gt;
                &lt;/body&gt;
                &lt;/html&gt;
        `)
}</span>

func (h *AdminHandler) handleLogin(c echo.Context) error <span class="cov0" title="0">{
        return h.renderTemplate(c, "login.html", nil)
}</span>

func (h *AdminHandler) handleLoginPost(c echo.Context) error <span class="cov0" title="0">{
        username := c.FormValue("username")
        password := c.FormValue("password")

        if username == h.username &amp;&amp; password == h.password </span><span class="cov0" title="0">{
                authValue := base64.StdEncoding.EncodeToString([]byte(username + ":" + password))
                cookie := http.Cookie{
                        Name:     "Authorization",
                        Value:    authValue,
                        Path:     "/admin",
                        HttpOnly: true,
                        MaxAge:   3600 * 24,
                }
                c.SetCookie(&amp;cookie)

                c.Response().Header().Set("HX-Redirect", "/admin/dashboard")
                return c.String(http.StatusOK, "Login successful. Redirecting...")
        }</span>

        <span class="cov0" title="0">return c.HTML(http.StatusUnauthorized, `&lt;div class="alert alert-danger"&gt;Invalid username or password&lt;/div&gt;`)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package admin

import (
        "github.com/labstack/echo/v4"
)

func (h *AdminHandler) Register(e *echo.Echo) <span class="cov0" title="0">{
        e.Static("/admin/assets", "pkg/admin/assets")

        h.initTemplates()

        adminGroup := e.Group("/admin")

        adminGroup.GET("", h.handleLogin)
        adminGroup.GET("/login", h.handleLogin)
        adminGroup.POST("/login", h.handleLoginPost)

        protected := adminGroup.Group("")
        protected.Use(h.basicAuthMiddleware)

        protected.GET("/dashboard", h.handleDashboard)

        protected.GET("/services", h.handleListServices)
        protected.GET("/services/new", h.handleNewService)
        protected.POST("/services", h.handleAddService)
        protected.GET("/services/:name", h.handleEditService)
        protected.POST("/services/:name", h.handleUpdateService)
        protected.DELETE("/services/:name", h.handleDeleteService)

        h.logger.Info("Admin routes registered")
}</span>

func (h *AdminHandler) handleDashboard(c echo.Context) error <span class="cov0" title="0">{
        return h.renderTemplate(c, "dashboard.html", nil)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package admin

import (
        "fmt"
        "net/http"
        "odin/pkg/config"
        "strconv"
        "strings"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

func (h *AdminHandler) handleListServices(c echo.Context) error <span class="cov0" title="0">{
        if len(h.config.Services) == 0 </span><span class="cov0" title="0">{
                return c.HTML(http.StatusOK, `&lt;div class="alert alert-info"&gt;No services configured. Add a new service to get started.&lt;/div&gt;`)
        }</span>

        <span class="cov0" title="0">html := `&lt;table class="table table-striped mt-4"&gt;
                &lt;thead&gt;
                        &lt;tr&gt;
                                &lt;th&gt;Name&lt;/th&gt;
                                &lt;th&gt;Base Path&lt;/th&gt;
                                &lt;th&gt;Targets&lt;/th&gt;
                                &lt;th&gt;Authentication&lt;/th&gt;
                                &lt;th&gt;Actions&lt;/th&gt;
                        &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
        `

        for _, svc := range h.config.Services </span><span class="cov0" title="0">{
                targets := svc.Targets[0]
                if len(svc.Targets) &gt; 1 </span><span class="cov0" title="0">{
                        targets += " +" + fmt.Sprint(len(svc.Targets)-1)
                }</span>

                <span class="cov0" title="0">authStatus := "Required"
                if !svc.Authentication </span><span class="cov0" title="0">{
                        authStatus = "Not Required"
                }</span>

                <span class="cov0" title="0">html += fmt.Sprintf(`
                        &lt;tr&gt;
                                &lt;td&gt;%s&lt;/td&gt;
                                &lt;td&gt;%s&lt;/td&gt;
                                &lt;td&gt;%s&lt;/td&gt;
                                &lt;td&gt;%s&lt;/td&gt;
                                &lt;td&gt;
                                        &lt;a href="/admin/services/%s" class="btn btn-sm btn-outline-primary"&gt;Edit&lt;/a&gt;
                                        &lt;button class="btn btn-sm btn-outline-danger" 
                                                        hx-delete="/admin/services/%s" 
                                                        hx-confirm="Are you sure you want to delete this service?"
                                                        hx-target="#service-list"
                                                        hx-swap="innerHTML"&gt;Delete&lt;/button&gt;
                                &lt;/td&gt;
                        &lt;/tr&gt;
                `, svc.Name, svc.BasePath, targets, authStatus, svc.Name, svc.Name)</span>
        }

        <span class="cov0" title="0">html += `
                &lt;/tbody&gt;
        &lt;/table&gt;
        `

        return c.HTML(http.StatusOK, html)</span>
}

func (h *AdminHandler) handleNewService(c echo.Context) error <span class="cov0" title="0">{
        data := map[string]interface{}{
                "AvailableServices": h.config.Services,
        }
        return h.renderTemplate(c, "add_service.html", data)
}</span>

func (h *AdminHandler) handleEditService(c echo.Context) error <span class="cov0" title="0">{
        name := c.Param("name")

        var svc *config.ServiceConfig
        for _, s := range h.config.Services </span><span class="cov0" title="0">{
                if s.Name == name </span><span class="cov0" title="0">{
                        svc = &amp;s
                        break</span>
                }
        }

        <span class="cov0" title="0">if svc == nil </span><span class="cov0" title="0">{
                return c.HTML(http.StatusNotFound, `&lt;div class="alert alert-danger"&gt;Service not found&lt;/div&gt;`)
        }</span>

        <span class="cov0" title="0">availableServices := make([]config.ServiceConfig, 0)
        for _, s := range h.config.Services </span><span class="cov0" title="0">{
                if s.Name != name </span><span class="cov0" title="0">{
                        availableServices = append(availableServices, s)
                }</span>
        }

        <span class="cov0" title="0">data := map[string]interface{}{
                "Service":           svc,
                "AvailableServices": availableServices,
                "StripBasePathYes":  svc.StripBasePath,
                "StripBasePathNo":   !svc.StripBasePath,
                "AuthYes":           svc.Authentication,
                "AuthNo":            !svc.Authentication,
                "LoadBalancingRR":   svc.LoadBalancing == "round-robin" || svc.LoadBalancing == "",
                "LoadBalancingRand": svc.LoadBalancing == "random",
        }

        return h.renderTemplate(c, "edit_service.html", data)</span>
}

func (h *AdminHandler) handleAddService(c echo.Context) error <span class="cov0" title="0">{
        name := c.FormValue("name")
        basePath := c.FormValue("basePath")

        for _, svc := range h.config.Services </span><span class="cov0" title="0">{
                if svc.Name == name </span><span class="cov0" title="0">{
                        return c.HTML(http.StatusBadRequest, `&lt;div class="alert alert-danger"&gt;A service with this name already exists&lt;/div&gt;`)
                }</span>
        }

        <span class="cov0" title="0">targets := parseMultilineInput(c.FormValue("targets"))
        if len(targets) == 0 </span><span class="cov0" title="0">{
                return c.HTML(http.StatusBadRequest, `&lt;div class="alert alert-danger"&gt;At least one target URL is required&lt;/div&gt;`)
        }</span>

        <span class="cov0" title="0">enableAggregation := c.FormValue("enableAggregation") == "on"
        aggregationConfig := parseAggregationConfig(c, enableAggregation)

        newSvc := config.ServiceConfig{
                Name:           name,
                BasePath:       basePath,
                Targets:        targets,
                StripBasePath:  c.FormValue("stripBasePath") == "true",
                Authentication: c.FormValue("authentication") == "true",
                LoadBalancing:  c.FormValue("loadBalancing"),
                Aggregation:    aggregationConfig,
                RetryCount:     1,
                RetryDelay:     100 * time.Millisecond,
                Timeout:        5 * time.Second,
        }

        h.config.Services = append(h.config.Services, newSvc)

        if err := h.saveConfig(); err != nil </span><span class="cov0" title="0">{
                return c.HTML(http.StatusInternalServerError, `&lt;div class="alert alert-danger"&gt;Failed to save configuration: `+err.Error()+`&lt;/div&gt;`)
        }</span>

        <span class="cov0" title="0">return c.HTML(http.StatusOK, `
                &lt;div class="alert alert-success"&gt;
                        Service added successfully! 
                        &lt;a href="/admin/dashboard"&gt;Return to dashboard&lt;/a&gt;
                &lt;/div&gt;
        `)</span>
}

func (h *AdminHandler) handleUpdateService(c echo.Context) error <span class="cov0" title="0">{
        name := c.Param("name")

        var svcIndex = -1
        for i, svc := range h.config.Services </span><span class="cov0" title="0">{
                if svc.Name == name </span><span class="cov0" title="0">{
                        svcIndex = i
                        break</span>
                }
        }

        <span class="cov0" title="0">if svcIndex == -1 </span><span class="cov0" title="0">{
                return c.HTML(http.StatusNotFound, `&lt;div class="alert alert-danger"&gt;Service not found&lt;/div&gt;`)
        }</span>

        <span class="cov0" title="0">targets := parseMultilineInput(c.FormValue("targets"))
        if len(targets) == 0 </span><span class="cov0" title="0">{
                return c.HTML(http.StatusBadRequest, `&lt;div class="alert alert-danger"&gt;At least one target URL is required&lt;/div&gt;`)
        }</span>

        // Parse timeout
        <span class="cov0" title="0">timeoutStr := c.FormValue("timeout")
        timeout, err := strconv.Atoi(timeoutStr)
        if err != nil || timeout &lt;= 0 </span><span class="cov0" title="0">{
                return c.HTML(http.StatusBadRequest, `&lt;div class="alert alert-danger"&gt;Invalid timeout value&lt;/div&gt;`)
        }</span>

        // Parse retry count
        <span class="cov0" title="0">retryCountStr := c.FormValue("retryCount")
        retryCount, err := strconv.Atoi(retryCountStr)
        if err != nil || retryCount &lt; 0 </span><span class="cov0" title="0">{
                return c.HTML(http.StatusBadRequest, `&lt;div class="alert alert-danger"&gt;Invalid retry count value&lt;/div&gt;`)
        }</span>

        // Update service configuration
        <span class="cov0" title="0">h.config.Services[svcIndex].BasePath = c.FormValue("basePath")
        h.config.Services[svcIndex].Targets = targets
        h.config.Services[svcIndex].StripBasePath = c.FormValue("stripBasePath") == "true"
        h.config.Services[svcIndex].Authentication = c.FormValue("authentication") == "true"
        h.config.Services[svcIndex].LoadBalancing = c.FormValue("loadBalancing")
        h.config.Services[svcIndex].Timeout = time.Duration(timeout) * time.Second
        h.config.Services[svcIndex].RetryCount = retryCount

        // Save configuration
        if err := h.saveConfig(); err != nil </span><span class="cov0" title="0">{
                return c.HTML(http.StatusInternalServerError, `&lt;div class="alert alert-danger"&gt;Failed to save configuration&lt;/div&gt;`)
        }</span>

        <span class="cov0" title="0">h.logger.WithFields(logrus.Fields{
                "service": name,
                "action":  "update",
        }).Info("Service updated")

        return c.HTML(http.StatusOK, `&lt;div class="alert alert-success"&gt;Service updated successfully&lt;/div&gt;`)</span>
}

func (h *AdminHandler) handleDeleteService(c echo.Context) error <span class="cov0" title="0">{
        name := c.Param("name")

        var found bool
        for i, svc := range h.config.Services </span><span class="cov0" title="0">{
                if svc.Name == name </span><span class="cov0" title="0">{
                        h.config.Services = append(h.config.Services[:i], h.config.Services[i+1:]...)
                        found = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return c.HTML(http.StatusNotFound, `&lt;div class="alert alert-danger"&gt;Service not found&lt;/div&gt;`)
        }</span>

        <span class="cov0" title="0">if err := h.saveConfig(); err != nil </span><span class="cov0" title="0">{
                return c.HTML(http.StatusInternalServerError, `&lt;div class="alert alert-danger"&gt;Failed to save configuration: `+err.Error()+`&lt;/div&gt;`)
        }</span>

        <span class="cov0" title="0">return h.handleListServices(c)</span>
}

func parseMultilineInput(input string) []string <span class="cov0" title="0">{
        lines := strings.Split(input, "\n")
        var result []string
        for _, line := range lines </span><span class="cov0" title="0">{
                line = strings.TrimSpace(line)
                if line != "" </span><span class="cov0" title="0">{
                        result = append(result, line)
                }</span>
        }
        <span class="cov0" title="0">return result</span>
}

func parseAggregationConfig(c echo.Context, enabled bool) *config.AggregationConfig <span class="cov0" title="0">{
        if !enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">aggregationConfig := &amp;config.AggregationConfig{
                Dependencies: []config.DependencyConfig{},
        }

        depCount := 0
        for i := 0; ; i++ </span><span class="cov0" title="0">{
                depServiceName := c.FormValue(fmt.Sprintf("dependencies[%d].service", i))
                if depServiceName == "" </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">depCount++</span>
        }

        <span class="cov0" title="0">dependencies := make([]config.DependencyConfig, depCount)
        for i := 0; i &lt; depCount; i++ </span><span class="cov0" title="0">{
                depServiceName := c.FormValue(fmt.Sprintf("dependencies[%d].service", i))
                depPath := c.FormValue(fmt.Sprintf("dependencies[%d].path", i))

                dependency := config.DependencyConfig{
                        Service:          depServiceName,
                        Path:             depPath,
                        ParameterMapping: []config.MappingConfig{},
                        ResultMapping:    []config.MappingConfig{},
                }

                for j := 0; ; j++ </span><span class="cov0" title="0">{
                        fromPath := c.FormValue(fmt.Sprintf("dependencies[%d].paramMapping[%d].from", i, j))
                        toParam := c.FormValue(fmt.Sprintf("dependencies[%d].paramMapping[%d].to", i, j))

                        if fromPath == "" || toParam == "" </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">dependency.ParameterMapping = append(dependency.ParameterMapping, config.MappingConfig{
                                From: fromPath,
                                To:   toParam,
                        })</span>
                }

                <span class="cov0" title="0">for j := 0; ; j++ </span><span class="cov0" title="0">{
                        fromPath := c.FormValue(fmt.Sprintf("dependencies[%d].resultMapping[%d].from", i, j))
                        toPath := c.FormValue(fmt.Sprintf("dependencies[%d].resultMapping[%d].to", i, j))

                        if fromPath == "" || toPath == "" </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">dependency.ResultMapping = append(dependency.ResultMapping, config.MappingConfig{
                                From: fromPath,
                                To:   toPath,
                        })</span>
                }

                <span class="cov0" title="0">dependencies[i] = dependency</span>
        }

        <span class="cov0" title="0">aggregationConfig.Dependencies = dependencies
        return aggregationConfig</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package admin

import (
        "html/template"
        "io"
        "net/http"
        "os"
        "path/filepath"
        "strings"

        "github.com/labstack/echo/v4"
)

type Template struct {
        templates *template.Template
}

func (t *Template) Render(w io.Writer, name string, data interface{}, c echo.Context) error <span class="cov0" title="0">{
        return t.templates.ExecuteTemplate(w, name, data)
}</span>

var templateDir = "pkg/admin/templates"

func (h *AdminHandler) initTemplates() <span class="cov0" title="0">{
        if _, err := os.Stat(templateDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                h.logger.Info("Creating templates directory")
                if err := os.MkdirAll(templateDir, 0755); err != nil </span><span class="cov0" title="0">{
                        h.logger.WithError(err).Fatal("Failed to create templates directory")
                }</span>

                <span class="cov0" title="0">h.createTemplateFile("login.html", loginTemplate)
                h.createTemplateFile("dashboard.html", dashboardTemplate)
                h.createTemplateFile("add_service.html", addServiceTemplate)
                h.createTemplateFile("edit_service.html", editServiceTemplate)</span>
        }
}

func (h *AdminHandler) createTemplateFile(name, content string) <span class="cov0" title="0">{
        path := filepath.Join(templateDir, name)
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                h.logger.Infof("Creating template: %s", name)
                if err := os.WriteFile(path, []byte(content), 0644); err != nil </span><span class="cov0" title="0">{
                        h.logger.WithError(err).Fatalf("Failed to create template: %s", name)
                }</span>
        }
}

func (h *AdminHandler) renderTemplate(c echo.Context, templateName string, data map[string]interface{}) error <span class="cov0" title="0">{
        acceptHeader := c.Request().Header.Get("Accept")
        if strings.Contains(acceptHeader, "application/json") &amp;&amp; !strings.HasPrefix(c.Path(), "/admin") </span><span class="cov0" title="0">{
                if data == nil </span><span class="cov0" title="0">{
                        data = map[string]interface{}{}
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusOK, data)</span>
        }

        <span class="cov0" title="0">tmpl, err := template.ParseFiles(filepath.Join(templateDir, templateName))
        if err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).Errorf("Failed to parse template: %s", templateName)

                content := getTemplateContent(templateName)
                if content != "Template not found" </span><span class="cov0" title="0">{
                        h.logger.Info("Using embedded template as fallback")
                        tmpl, err = template.New(templateName).Parse(content)
                        if err != nil </span><span class="cov0" title="0">{
                                return c.String(http.StatusInternalServerError, "Template error")
                        }</span>
                } else<span class="cov0" title="0"> {
                        return c.String(http.StatusInternalServerError, "Template not found")
                }</span>
        }

        <span class="cov0" title="0">var output strings.Builder
        if err := tmpl.Execute(&amp;output, data); err != nil </span><span class="cov0" title="0">{
                h.logger.WithError(err).Errorf("Failed to execute template: %s", templateName)
                return c.String(http.StatusInternalServerError, "Template execution error")
        }</span>

        <span class="cov0" title="0">c.Response().Header().Set("Content-Type", "text/html; charset=utf-8")
        return c.HTML(http.StatusOK, output.String())</span>
}

func getTemplateContent(name string) string <span class="cov0" title="0">{
        switch name </span>{
        case "login.html":<span class="cov0" title="0">
                return loginTemplate</span>
        case "dashboard.html":<span class="cov0" title="0">
                return dashboardTemplate</span>
        case "add_service.html":<span class="cov0" title="0">
                return addServiceTemplate</span>
        case "edit_service.html":<span class="cov0" title="0">
                return editServiceTemplate</span>
        case "service_list.html":<span class="cov0" title="0">
                return `{{define "service_list.html"}}
&lt;table class="table table-striped"&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Name&lt;/th&gt;
      &lt;th&gt;Base Path&lt;/th&gt;
      &lt;th&gt;Targets&lt;/th&gt;
      &lt;th&gt;Actions&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    {{range .Services}}
    &lt;tr&gt;
      &lt;td&gt;{{.Name}}&lt;/td&gt;
      &lt;td&gt;{{.BasePath}}&lt;/td&gt;
      &lt;td&gt;{{index .Targets 0}}&lt;/td&gt;
      &lt;td&gt;
        &lt;a href="/admin/services/{{.Name}}" class="btn btn-sm btn-outline-primary"&gt;Edit&lt;/a&gt;
        &lt;button
          class="btn btn-sm btn-outline-danger"
          hx-delete="/admin/services/{{.Name}}"
          hx-confirm="Are you sure you want to delete this service?"
          hx-target="#service-list"
          hx-swap="innerHTML"
        &gt;Delete&lt;/button&gt;
      &lt;/td&gt;
    &lt;/tr&gt;
    {{end}}
  &lt;/tbody&gt;
&lt;/table&gt;
{{end}}`</span>
        default:<span class="cov0" title="0">
                return "Template not found"</span>
        }
}

const (
        loginTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;Login - Odin API Gateway&lt;/title&gt;
        &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"&gt;
        &lt;script src="https://unpkg.com/htmx.org@1.9.11"&gt;&lt;/script&gt;
        &lt;style&gt;
                body {
                        display: flex;
                        align-items: center;
                        padding-top: 40px;
                        padding-bottom: 40px;
                        background-color: #f5f5f5;
                        height: 100vh;
                }
                .form-signin {
                        width: 100%;
                        max-width: 330px;
                        padding: 15px;
                        margin: auto;
                }
        &lt;/style&gt;
&lt;/head&gt;
&lt;body class="text-center"&gt;
        &lt;main class="form-signin"&gt;
                &lt;form hx-post="/admin/login" hx-target="#login-message"&gt;
                        &lt;h1 class="h3 mb-3 fw-normal"&gt;Odin API Gateway&lt;/h1&gt;
                        &lt;h2 class="h5 mb-3 fw-normal"&gt;Admin Login&lt;/h2&gt;
                        &lt;div id="login-message"&gt;&lt;/div&gt;
                        
                        &lt;div class="form-floating mb-3"&gt;
                                &lt;input type="text" class="form-control" id="username" name="username" placeholder="Username" required&gt;
                                &lt;label for="username"&gt;Username&lt;/label&gt;
                        &lt;/div&gt;
                        &lt;div class="form-floating mb-3"&gt;
                                &lt;input type="password" class="form-control" id="password" name="password" placeholder="Password" required&gt;
                                &lt;label for="password"&gt;Password&lt;/label&gt;
                        &lt;/div&gt;
                        
                        &lt;button class="w-100 btn btn-lg btn-primary" type="submit"&gt;Sign in&lt;/button&gt;
                &lt;/form&gt;
        &lt;/main&gt;
        &lt;script&gt;
                document.addEventListener('htmx:afterSwap', function(event) {
                        const redirectTo = event.detail.xhr.getResponseHeader('HX-Redirect');
                        if (redirectTo) {
                                window.location.href = redirectTo;
                        }
                });
        &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;`

        dashboardTemplate = `&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;title&gt;Dashboard - Odin API Gateway&lt;/title&gt;
        &lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"&gt;
        &lt;script src="https://unpkg.com/htmx.org@1.9.11"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
        &lt;div class="container py-4"&gt;
                &lt;header class="d-flex justify-content-between align-items-center pb-3 mb-4 border-bottom"&gt;
                        &lt;h1&gt;Odin API Gateway&lt;/h1&gt;
                        &lt;div&gt;
                                &lt;a href="/admin/services/new" class="btn btn-primary"&gt;Add Service&lt;/a&gt;
                                &lt;a href="/admin/login" class="btn btn-secondary ms-2"&gt;Logout&lt;/a&gt;
                        &lt;/div&gt;
                &lt;/header&gt;
                
                &lt;main&gt;
                        &lt;h2&gt;Service Configuration&lt;/h2&gt;
                        &lt;p class="lead"&gt;Manage your gateway service configurations.&lt;/p&gt;
                        
                        &lt;div id="service-list" hx-get="/admin/services" hx-trigger="load"&gt;
                                &lt;div class="d-flex justify-content-center"&gt;
                                        &lt;div class="spinner-border" role="status"&gt;
                                                &lt;span class="visually-hidden"&gt;Loading...&lt;/span&gt;
                                        &lt;/div&gt;
                                &lt;/div&gt;
                        &lt;/div&gt;
                &lt;/main&gt;
                
                &lt;footer class="pt-5 my-5 text-muted border-top"&gt;
                        &amp;copy; 2023-2024 Odin API Gateway
                &lt;/footer&gt;
        &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;`

        addServiceTemplate  = `&lt;!-- Add Service Template would go here --&gt;`
        editServiceTemplate = `&lt;!-- Edit Service Template would go here --&gt;`
)
</pre>
		
		<pre class="file" id="file6" style="display: none">package auth

import (
        "fmt"
        "net/http"
        "odin/pkg/config"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/labstack/echo/v4"
        "gopkg.in/yaml.v3"
)

type AuthSecrets struct {
        JWTSecret string `yaml:"jwtSecret"`
}

type JWTConfig struct {
        Secret          string        `yaml:"secret"`
        AccessTokenTTL  time.Duration `yaml:"accessTokenTTL"`
        RefreshTokenTTL time.Duration `yaml:"refreshTokenTTL"`
}

type Claims struct {
        UserID   string `json:"user_id"`
        Username string `json:"username"`
        Role     string `json:"role"`
        jwt.RegisteredClaims
}

type JWTManager struct {
        secret          string
        accessTokenTTL  time.Duration
        refreshTokenTTL time.Duration
}

func NewJWTManager(config JWTConfig) *JWTManager <span class="cov0" title="0">{
        return &amp;JWTManager{
                secret:          config.Secret,
                accessTokenTTL:  config.AccessTokenTTL,
                refreshTokenTTL: config.RefreshTokenTTL,
        }
}</span>

func (jm *JWTManager) GenerateToken(claims *Claims) (string, error) <span class="cov0" title="0">{
        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(jm.secret))
}</span>

func (jm *JWTManager) ValidateToken(tokenString string) (*Claims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(jm.secret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("invalid token")</span>
}

func loadJWTSecret() (string, error) <span class="cov0" title="0">{
        secretsPaths := []string{
                "config/auth_secrets.yaml",
                "/etc/odin/auth_secrets.yaml",
                filepath.Join(os.Getenv("HOME"), ".odin", "auth_secrets.yaml"),
        }

        for _, path := range secretsPaths </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        data, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">var secrets AuthSecrets
                        if err := yaml.Unmarshal(data, &amp;secrets); err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if secrets.JWTSecret != "" </span><span class="cov0" title="0">{
                                return secrets.JWTSecret, nil
                        }</span>
                }
        }

        <span class="cov0" title="0">if envSecret := os.Getenv("ODIN_JWT_SECRET"); envSecret != "" </span><span class="cov0" title="0">{
                return envSecret, nil
        }</span>

        <span class="cov0" title="0">return "", fmt.Errorf("couldn't load JWT secret from any source")</span>
}

type JWTClaims struct {
        UserID   string `json:"user_id"`
        Username string `json:"username"`
        Role     string `json:"role"`
        jwt.RegisteredClaims
}

func NewJWTMiddleware(config config.AuthConfig) echo.MiddlewareFunc <span class="cov0" title="0">{
        jwtSecret, err := loadJWTSecret()
        if err != nil </span><span class="cov0" title="0">{
                jwtSecret = config.JWTSecret
        }</span>

        <span class="cov0" title="0">if jwtSecret == "" </span><span class="cov0" title="0">{
                fmt.Println("WARNING: JWT secret is not configured")
        }</span>

        <span class="cov0" title="0">ignorePaths := make([]*regexp.Regexp, 0)
        for _, regex := range config.IgnorePathRegexes </span><span class="cov0" title="0">{
                compiledRegex, err := regexp.Compile(regex)
                if err == nil </span><span class="cov0" title="0">{
                        ignorePaths = append(ignorePaths, compiledRegex)
                }</span>
        }

        <span class="cov0" title="0">return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        path := c.Request().URL.Path

                        for _, regex := range ignorePaths </span><span class="cov0" title="0">{
                                if regex.MatchString(path) </span><span class="cov0" title="0">{
                                        return next(c)
                                }</span>
                        }

                        <span class="cov0" title="0">authHeader := c.Request().Header.Get("Authorization")
                        if authHeader == "" </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "Missing authorization header")
                        }</span>

                        <span class="cov0" title="0">tokenParts := strings.Split(authHeader, " ")
                        if len(tokenParts) != 2 || tokenParts[0] != "Bearer" </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "Invalid authorization format")
                        }</span>

                        <span class="cov0" title="0">tokenString := tokenParts[1]

                        token, err := jwt.ParseWithClaims(tokenString, &amp;JWTClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                                }</span>
                                <span class="cov0" title="0">return []byte(jwtSecret), nil</span>
                        })

                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "Invalid or expired token")
                        }</span>

                        <span class="cov0" title="0">if claims, ok := token.Claims.(*JWTClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                                c.Set("user", claims)
                                return next(c)
                        }</span>

                        <span class="cov0" title="0">return echo.NewHTTPError(http.StatusUnauthorized, "Invalid token claims")</span>
                }
        }
}

func GenerateToken(userID, username, role string, secret string, expiry time.Duration) (string, error) <span class="cov0" title="0">{
        if secret == "" </span><span class="cov0" title="0">{
                var err error
                secret, err = loadJWTSecret()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("no JWT secret available: %w", err)
                }</span>
        }

        <span class="cov0" title="0">claims := &amp;JWTClaims{
                UserID:   userID,
                Username: username,
                Role:     role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(expiry)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString([]byte(secret))</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

type OAuth2Config struct {
        Enabled      bool                      `yaml:"enabled"`
        Providers    map[string]OAuth2Provider `yaml:"providers"`
        DefaultScope string                    `yaml:"defaultScope"`
        TokenTTL     time.Duration             `yaml:"tokenTTL"`
}

type OAuth2Provider struct {
        ClientID     string   `yaml:"clientId"`
        ClientSecret string   `yaml:"clientSecret"`
        AuthURL      string   `yaml:"authUrl"`
        TokenURL     string   `yaml:"tokenUrl"`
        UserInfoURL  string   `yaml:"userInfoUrl"`
        Scopes       []string `yaml:"scopes"`
        RedirectURL  string   `yaml:"redirectUrl"`
}

type OAuth2Manager struct {
        config    OAuth2Config
        logger    *logrus.Logger
        providers map[string]*OAuth2Provider
}

type OAuth2Token struct {
        AccessToken  string    `json:"access_token"`
        TokenType    string    `json:"token_type"`
        ExpiresIn    int       `json:"expires_in"`
        RefreshToken string    `json:"refresh_token,omitempty"`
        Scope        string    `json:"scope,omitempty"`
        ExpiresAt    time.Time `json:"expires_at"`
}

type OAuth2UserInfo struct {
        ID       string `json:"id"`
        Email    string `json:"email"`
        Name     string `json:"name"`
        Provider string `json:"provider"`
}

func NewOAuth2Manager(config OAuth2Config, logger *logrus.Logger) *OAuth2Manager <span class="cov0" title="0">{
        providers := make(map[string]*OAuth2Provider)
        for name, provider := range config.Providers </span><span class="cov0" title="0">{
                providerCopy := provider
                providers[name] = &amp;providerCopy
        }</span>

        <span class="cov0" title="0">return &amp;OAuth2Manager{
                config:    config,
                logger:    logger,
                providers: providers,
        }</span>
}

func (om *OAuth2Manager) GetAuthURL(provider, state string) (string, error) <span class="cov0" title="0">{
        p, exists := om.providers[provider]
        if !exists </span><span class="cov0" title="0">{
                return "", fmt.Errorf("provider %s not found", provider)
        }</span>

        <span class="cov0" title="0">params := url.Values{
                "client_id":     {p.ClientID},
                "redirect_uri":  {p.RedirectURL},
                "response_type": {"code"},
                "scope":         {strings.Join(p.Scopes, " ")},
                "state":         {state},
        }

        return p.AuthURL + "?" + params.Encode(), nil</span>
}

func (om *OAuth2Manager) ExchangeCodeForToken(ctx context.Context, provider, code string) (*OAuth2Token, error) <span class="cov0" title="0">{
        p, exists := om.providers[provider]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider %s not found", provider)
        }</span>

        <span class="cov0" title="0">data := url.Values{
                "client_id":     {p.ClientID},
                "client_secret": {p.ClientSecret},
                "code":          {code},
                "grant_type":    {"authorization_code"},
                "redirect_uri":  {p.RedirectURL},
        }

        req, err := http.NewRequestWithContext(ctx, "POST", p.TokenURL, strings.NewReader(data.Encode()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

        client := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token exchange failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var token OAuth2Token
        if err := json.NewDecoder(resp.Body).Decode(&amp;token); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">token.ExpiresAt = time.Now().Add(time.Duration(token.ExpiresIn) * time.Second)
        return &amp;token, nil</span>
}

func (om *OAuth2Manager) GetUserInfo(ctx context.Context, provider string, token *OAuth2Token) (*OAuth2UserInfo, error) <span class="cov0" title="0">{
        p, exists := om.providers[provider]
        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("provider %s not found", provider)
        }</span>

        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "GET", p.UserInfoURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">req.Header.Set("Authorization", "Bearer "+token.AccessToken)

        client := &amp;http.Client{Timeout: 10 * time.Second}
        resp, err := client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user info request failed with status: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var userInfo OAuth2UserInfo
        if err := json.NewDecoder(resp.Body).Decode(&amp;userInfo); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">userInfo.Provider = provider
        return &amp;userInfo, nil</span>
}

func (om *OAuth2Manager) ValidateToken(ctx context.Context, provider string, token *OAuth2Token) bool <span class="cov0" title="0">{
        if time.Now().After(token.ExpiresAt) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Additional validation can be added here
        <span class="cov0" title="0">return true</span>
}

func OAuth2Middleware(manager *OAuth2Manager) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        authHeader := c.Request().Header.Get("Authorization")
                        if authHeader == "" </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "Missing authorization header")
                        }</span>

                        <span class="cov0" title="0">parts := strings.SplitN(authHeader, " ", 2)
                        if len(parts) != 2 || parts[0] != "Bearer" </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusUnauthorized, "Invalid authorization header format")
                        }</span>

                        // Here you would validate the OAuth2 token
                        // This is a simplified version - in practice, you'd need to
                        // validate against the provider or store token information

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package cache

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "odin/pkg/config"
        "time"

        "github.com/patrickmn/go-cache"
        "github.com/redis/go-redis/v9"
)

type CachedResponse struct {
        Headers    http.Header `json:"headers"`
        StatusCode int         `json:"status_code"`
        Body       []byte      `json:"body"`
}

type Store interface {
        Get(key string) (interface{}, bool)
        Set(key string, value interface{}, ttl time.Duration)
        Delete(key string)
        Clear()
        Close() error
}

type LocalStore struct {
        cache *cache.Cache
}

type RedisStore struct {
        client *redis.Client
        ttl    time.Duration
}

func NewStore(config config.CacheConfig) (Store, error) <span class="cov0" title="0">{
        switch config.Strategy </span>{
        case "local":<span class="cov0" title="0">
                return &amp;LocalStore{
                        cache: cache.New(config.TTL, time.Duration(config.TTL*2)),
                }, nil</span>
        case "redis":<span class="cov0" title="0">
                opts, err := redis.ParseURL(config.RedisURL)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid Redis URL: %w", err)
                }</span>
                <span class="cov0" title="0">client := redis.NewClient(opts)
                if err := client.Ping(context.Background()).Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to connect to Redis: %w", err)
                }</span>
                <span class="cov0" title="0">return &amp;RedisStore{
                        client: client,
                        ttl:    config.TTL,
                }, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported cache strategy: %s", config.Strategy)</span>
        }
}

func (s *LocalStore) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        if value, found := s.cache.Get(key); found </span><span class="cov0" title="0">{
                return value, true
        }</span>
        <span class="cov0" title="0">return nil, false</span>
}

func (s *LocalStore) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        s.cache.Set(key, value, cache.DefaultExpiration)
}</span>

func (s *LocalStore) Delete(key string) <span class="cov0" title="0">{
        s.cache.Delete(key)
}</span>

func (s *LocalStore) Clear() <span class="cov0" title="0">{
        s.cache.Flush()
}</span>

func (s *LocalStore) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (s *RedisStore) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        ctx := context.Background()
        data, err := s.client.Get(ctx, key).Bytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">var response CachedResponse
        if err := json.Unmarshal(data, &amp;response); err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">return &amp;response, true</span>
}

func (s *RedisStore) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        ctx := context.Background()
        data, err := json.Marshal(value)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if ttl &gt; 0 </span><span class="cov0" title="0">{
                s.client.Set(ctx, key, data, ttl)
        }</span> else<span class="cov0" title="0"> {
                s.client.Set(ctx, key, data, s.ttl)
        }</span>
}

func (s *RedisStore) Delete(key string) <span class="cov0" title="0">{
        ctx := context.Background()
        s.client.Del(ctx, key)
}</span>

func (s *RedisStore) Clear() <span class="cov0" title="0">{
        ctx := context.Background()
        iter := s.client.Scan(ctx, 0, "cache:*", 100).Iterator()
        for iter.Next(ctx) </span><span class="cov0" title="0">{
                s.client.Del(ctx, iter.Val())
        }</span>
}

func (s *RedisStore) Close() error <span class="cov0" title="0">{
        return s.client.Close()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package cache

import (
        "crypto/md5"
        "fmt"
        "net/http"
        "net/url"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

type CacheStrategy string

const (
        StrategyTTL          CacheStrategy = "ttl"
        StrategyConditional  CacheStrategy = "conditional"
        StrategyVary         CacheStrategy = "vary"
        StrategyUserContext  CacheStrategy = "user_context"
        StrategyInvalidation CacheStrategy = "invalidation"
)

type CacheConfig struct {
        Strategy         CacheStrategy `yaml:"strategy"`
        TTL              time.Duration `yaml:"ttl"`
        VaryHeaders      []string      `yaml:"varyHeaders"`
        CacheableStatus  []int         `yaml:"cacheableStatus"`
        IgnoreHeaders    []string      `yaml:"ignoreHeaders"`
        UserContextKey   string        `yaml:"userContextKey"`
        InvalidationTags []string      `yaml:"invalidationTags"`
        MaxSize          int64         `yaml:"maxSize"`
        CompressResponse bool          `yaml:"compressResponse"`
}

type CacheEntry struct {
        Data         []byte            `json:"data"`
        Headers      map[string]string `json:"headers"`
        StatusCode   int               `json:"status_code"`
        Timestamp    time.Time         `json:"timestamp"`
        TTL          time.Duration     `json:"ttl"`
        ETag         string            `json:"etag"`
        LastModified string            `json:"last_modified"`
        Tags         []string          `json:"tags"`
        UserContext  string            `json:"user_context"`
}

type StrategyManager struct {
        store  Store
        config CacheConfig
        logger *logrus.Logger
}

func NewStrategyManager(store Store, config CacheConfig, logger *logrus.Logger) *StrategyManager <span class="cov0" title="0">{
        if len(config.CacheableStatus) == 0 </span><span class="cov0" title="0">{
                config.CacheableStatus = []int{200, 301, 302, 404}
        }</span>

        <span class="cov0" title="0">return &amp;StrategyManager{
                store:  store,
                config: config,
                logger: logger,
        }</span>
}

func (sm *StrategyManager) GenerateKey(req *http.Request, userContext string) string <span class="cov0" title="0">{
        var keyParts []string

        keyParts = append(keyParts, req.Method)
        keyParts = append(keyParts, req.URL.Path)

        if req.URL.RawQuery != "" </span><span class="cov0" title="0">{
                params, err := url.ParseQuery(req.URL.RawQuery)
                if err == nil </span><span class="cov0" title="0">{
                        var sortedParams []string
                        for key, values := range params </span><span class="cov0" title="0">{
                                for _, value := range values </span><span class="cov0" title="0">{
                                        sortedParams = append(sortedParams, fmt.Sprintf("%s=%s", key, value))
                                }</span>
                        }
                        <span class="cov0" title="0">sort.Strings(sortedParams)
                        keyParts = append(keyParts, strings.Join(sortedParams, "&amp;"))</span>
                }
        }

        <span class="cov0" title="0">if sm.config.Strategy == StrategyVary &amp;&amp; len(sm.config.VaryHeaders) &gt; 0 </span><span class="cov0" title="0">{
                var varyParts []string
                for _, header := range sm.config.VaryHeaders </span><span class="cov0" title="0">{
                        value := req.Header.Get(header)
                        if value != "" </span><span class="cov0" title="0">{
                                varyParts = append(varyParts, fmt.Sprintf("%s:%s", header, value))
                        }</span>
                }
                <span class="cov0" title="0">if len(varyParts) &gt; 0 </span><span class="cov0" title="0">{
                        keyParts = append(keyParts, strings.Join(varyParts, "|"))
                }</span>
        }

        <span class="cov0" title="0">if sm.config.Strategy == StrategyUserContext &amp;&amp; userContext != "" </span><span class="cov0" title="0">{
                keyParts = append(keyParts, "user:"+userContext)
        }</span>

        <span class="cov0" title="0">key := strings.Join(keyParts, ":")
        hash := md5.Sum([]byte(key))
        return fmt.Sprintf("cache:%x", hash)</span>
}

func (sm *StrategyManager) ShouldCache(statusCode int, headers http.Header) bool <span class="cov0" title="0">{
        // Check cache control headers first
        if cacheControl := headers.Get("Cache-Control"); cacheControl != "" </span><span class="cov0" title="0">{
                if strings.Contains(cacheControl, "no-cache") || strings.Contains(cacheControl, "no-store") </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check if status code is cacheable
        <span class="cov0" title="0">for _, status := range sm.config.CacheableStatus </span><span class="cov0" title="0">{
                if status == statusCode </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (sm *StrategyManager) Get(key string) (*CacheEntry, bool) <span class="cov0" title="0">{
        data, found := sm.store.Get(key)
        if !found </span><span class="cov0" title="0">{
                return nil, false
        }</span>

        <span class="cov0" title="0">entry, ok := data.(*CacheEntry)
        if !ok </span><span class="cov0" title="0">{
                sm.logger.WithField("key", key).Warn("Invalid cache entry type")
                sm.store.Delete(key)
                return nil, false
        }</span>

        <span class="cov0" title="0">if sm.isExpired(entry) </span><span class="cov0" title="0">{
                sm.store.Delete(key)
                return nil, false
        }</span>

        <span class="cov0" title="0">return entry, true</span>
}

func (sm *StrategyManager) Set(key string, entry *CacheEntry) <span class="cov0" title="0">{
        var ttl time.Duration

        switch sm.config.Strategy </span>{
        case StrategyTTL:<span class="cov0" title="0">
                ttl = sm.config.TTL</span>
        case StrategyConditional:<span class="cov0" title="0">
                ttl = sm.getConditionalTTL(entry)</span>
        default:<span class="cov0" title="0">
                ttl = sm.config.TTL</span>
        }

        <span class="cov0" title="0">if ttl &lt;= 0 </span><span class="cov0" title="0">{
                ttl = 5 * time.Minute
        }</span>

        <span class="cov0" title="0">entry.TTL = ttl
        entry.Timestamp = time.Now()

        sm.store.Set(key, entry, ttl)

        sm.logger.WithFields(logrus.Fields{
                "key":      key,
                "ttl":      ttl,
                "strategy": sm.config.Strategy,
        }).Debug("Cache entry stored")</span>
}

func (sm *StrategyManager) isExpired(entry *CacheEntry) bool <span class="cov0" title="0">{
        return time.Since(entry.Timestamp) &gt; entry.TTL
}</span>

func (sm *StrategyManager) getConditionalTTL(entry *CacheEntry) time.Duration <span class="cov0" title="0">{
        if entry.Headers["Cache-Control"] != "" </span><span class="cov0" title="0">{
                cacheControl := entry.Headers["Cache-Control"]

                if strings.Contains(cacheControl, "max-age=") </span><span class="cov0" title="0">{
                        parts := strings.Split(cacheControl, "max-age=")
                        if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                                maxAgeStr := strings.Split(parts[1], ",")[0]
                                maxAgeStr = strings.TrimSpace(maxAgeStr)
                                if seconds := parseInt(maxAgeStr); seconds &gt; 0 </span><span class="cov0" title="0">{
                                        return time.Duration(seconds) * time.Second
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">if entry.Headers["Expires"] != "" </span><span class="cov0" title="0">{
                if expires, err := time.Parse(time.RFC1123, entry.Headers["Expires"]); err == nil </span><span class="cov0" title="0">{
                        ttl := time.Until(expires)
                        if ttl &gt; 0 </span><span class="cov0" title="0">{
                                return ttl
                        }</span>
                }
        }

        <span class="cov0" title="0">return sm.config.TTL</span>
}

func (sm *StrategyManager) InvalidateByTags(tags []string) <span class="cov0" title="0">{
        sm.logger.WithField("tags", tags).Info("Invalidating cache by tags")
        sm.store.Clear()
}</span>

func (sm *StrategyManager) InvalidateByPattern(pattern string) <span class="cov0" title="0">{
        sm.logger.WithField("pattern", pattern).Info("Invalidating cache by pattern")
        sm.store.Clear()
}</span>

func (sm *StrategyManager) CheckConditional(req *http.Request, entry *CacheEntry) (bool, int) <span class="cov0" title="0">{
        ifNoneMatch := req.Header.Get("If-None-Match")
        if ifNoneMatch != "" &amp;&amp; entry.ETag != "" </span><span class="cov0" title="0">{
                if ifNoneMatch == entry.ETag || ifNoneMatch == "*" </span><span class="cov0" title="0">{
                        return true, http.StatusNotModified
                }</span>
        }

        <span class="cov0" title="0">ifModifiedSince := req.Header.Get("If-Modified-Since")
        if ifModifiedSince != "" &amp;&amp; entry.LastModified != "" </span><span class="cov0" title="0">{
                if clientTime, err := time.Parse(time.RFC1123, ifModifiedSince); err == nil </span><span class="cov0" title="0">{
                        if serverTime, err := time.Parse(time.RFC1123, entry.LastModified); err == nil </span><span class="cov0" title="0">{
                                if !serverTime.After(clientTime) </span><span class="cov0" title="0">{
                                        return true, http.StatusNotModified
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, 0</span>
}

func parseInt(s string) int <span class="cov0" title="0">{
        var result int
        for _, char := range s </span><span class="cov0" title="0">{
                if char &gt;= '0' &amp;&amp; char &lt;= '9' </span><span class="cov0" title="0">{
                        result = result*10 + int(char-'0')
                }</span> else<span class="cov0" title="0"> {
                        break</span>
                }
        }
        <span class="cov0" title="0">return result</span>
}

type MemoryStore struct {
        mu    sync.RWMutex
        items map[string]interface{}
}

func NewMemoryStore() *MemoryStore <span class="cov0" title="0">{
        return &amp;MemoryStore{
                items: make(map[string]interface{}),
        }
}</span>

func (m *MemoryStore) Get(key string) (interface{}, bool) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()
        value, exists := m.items[key]
        return value, exists
}</span>

func (m *MemoryStore) Set(key string, value interface{}, ttl time.Duration) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.items[key] = value
}</span>

func (m *MemoryStore) Delete(key string) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        delete(m.items, key)
}</span>

func (m *MemoryStore) Clear() <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        m.items = make(map[string]interface{})
}</span>

func (m *MemoryStore) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package circuit

import (
        "context"
        "errors"
        "sync"
        "time"

        "github.com/sirupsen/logrus"
)

var (
        ErrCircuitOpen     = errors.New("circuit breaker is open")
        ErrTooManyRequests = errors.New("too many requests")
)

type State int

const (
        StateClosed State = iota
        StateHalfOpen
        StateOpen
)

func (s State) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StateClosed:<span class="cov0" title="0">
                return "closed"</span>
        case StateHalfOpen:<span class="cov0" title="0">
                return "half-open"</span>
        case StateOpen:<span class="cov0" title="0">
                return "open"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

type Config struct {
        MaxRequests   uint32        `yaml:"maxRequests"`
        Interval      time.Duration `yaml:"interval"`
        Timeout       time.Duration `yaml:"timeout"`
        FailureRatio  float64       `yaml:"failureRatio"`
        MinRequests   uint32        `yaml:"minRequests"`
        ReadyToTrip   func(counts Counts) bool
        OnStateChange func(name string, from State, to State)
        IsSuccessful  func(err error) bool
}

type Counts struct {
        Requests             uint32
        TotalSuccesses       uint32
        TotalFailures        uint32
        ConsecutiveSuccesses uint32
        ConsecutiveFailures  uint32
}

func (c Counts) SuccessRatio() float64 <span class="cov0" title="0">{
        if c.Requests == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(c.TotalSuccesses) / float64(c.Requests)</span>
}

func (c Counts) FailureRatio() float64 <span class="cov0" title="0">{
        if c.Requests == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return float64(c.TotalFailures) / float64(c.Requests)</span>
}

type CircuitBreaker struct {
        name          string
        maxRequests   uint32
        interval      time.Duration
        timeout       time.Duration
        readyToTrip   func(counts Counts) bool
        onStateChange func(name string, from State, to State)
        isSuccessful  func(err error) bool

        mutex      sync.Mutex
        state      State
        generation uint64
        counts     Counts
        expiry     time.Time

        logger *logrus.Logger
}

func NewCircuitBreaker(name string, config Config, logger *logrus.Logger) *CircuitBreaker <span class="cov0" title="0">{
        cb := &amp;CircuitBreaker{
                name:          name,
                maxRequests:   config.MaxRequests,
                interval:      config.Interval,
                timeout:       config.Timeout,
                readyToTrip:   config.ReadyToTrip,
                onStateChange: config.OnStateChange,
                isSuccessful:  config.IsSuccessful,
                logger:        logger,
        }

        if cb.maxRequests == 0 </span><span class="cov0" title="0">{
                cb.maxRequests = 1
        }</span>

        <span class="cov0" title="0">if cb.interval &lt;= 0 </span><span class="cov0" title="0">{
                cb.interval = 60 * time.Second
        }</span>

        <span class="cov0" title="0">if cb.timeout &lt;= 0 </span><span class="cov0" title="0">{
                cb.timeout = 60 * time.Second
        }</span>

        <span class="cov0" title="0">if cb.readyToTrip == nil </span><span class="cov0" title="0">{
                cb.readyToTrip = func(counts Counts) bool </span><span class="cov0" title="0">{
                        return counts.Requests &gt;= config.MinRequests &amp;&amp; counts.FailureRatio() &gt;= config.FailureRatio
                }</span>
        }

        <span class="cov0" title="0">if cb.isSuccessful == nil </span><span class="cov0" title="0">{
                cb.isSuccessful = func(err error) bool </span><span class="cov0" title="0">{
                        return err == nil
                }</span>
        }

        <span class="cov0" title="0">cb.toNewGeneration(time.Now())
        return cb</span>
}

func (cb *CircuitBreaker) Execute(req func() (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        generation, err := cb.beforeRequest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                e := recover()
                if e != nil </span><span class="cov0" title="0">{
                        cb.afterRequest(generation, false)
                        panic(e)</span>
                }
        }()

        <span class="cov0" title="0">result, err := req()
        cb.afterRequest(generation, cb.isSuccessful(err))
        return result, err</span>
}

func (cb *CircuitBreaker) ExecuteWithContext(ctx context.Context, req func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        generation, err := cb.beforeRequest()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                e := recover()
                if e != nil </span><span class="cov0" title="0">{
                        cb.afterRequest(generation, false)
                        panic(e)</span>
                }
        }()

        <span class="cov0" title="0">result, err := req(ctx)
        cb.afterRequest(generation, cb.isSuccessful(err))
        return result, err</span>
}

func (cb *CircuitBreaker) beforeRequest() (uint64, error) <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        now := time.Now()
        state, generation := cb.currentState(now)

        if state == StateOpen </span><span class="cov0" title="0">{
                return generation, ErrCircuitOpen
        }</span> else<span class="cov0" title="0"> if state == StateHalfOpen &amp;&amp; cb.counts.Requests &gt;= cb.maxRequests </span><span class="cov0" title="0">{
                return generation, ErrTooManyRequests
        }</span>

        <span class="cov0" title="0">cb.counts.Requests++
        return generation, nil</span>
}

func (cb *CircuitBreaker) afterRequest(before uint64, success bool) <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        now := time.Now()
        state, generation := cb.currentState(now)
        if generation != before </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if success </span><span class="cov0" title="0">{
                cb.onSuccess(state, now)
        }</span> else<span class="cov0" title="0"> {
                cb.onFailure(state, now)
        }</span>
}

func (cb *CircuitBreaker) onSuccess(state State, now time.Time) <span class="cov0" title="0">{
        cb.counts.TotalSuccesses++
        cb.counts.ConsecutiveSuccesses++
        cb.counts.ConsecutiveFailures = 0

        if state == StateHalfOpen </span><span class="cov0" title="0">{
                cb.setState(StateClosed, now)
        }</span>
}

func (cb *CircuitBreaker) onFailure(state State, now time.Time) <span class="cov0" title="0">{
        cb.counts.TotalFailures++
        cb.counts.ConsecutiveFailures++
        cb.counts.ConsecutiveSuccesses = 0

        if cb.readyToTrip(cb.counts) </span><span class="cov0" title="0">{
                cb.setState(StateOpen, now)
        }</span>
}

func (cb *CircuitBreaker) currentState(now time.Time) (State, uint64) <span class="cov0" title="0">{
        switch cb.state </span>{
        case StateClosed:<span class="cov0" title="0">
                if !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) </span><span class="cov0" title="0">{
                        cb.toNewGeneration(now)
                }</span>
        case StateOpen:<span class="cov0" title="0">
                if cb.expiry.Before(now) </span><span class="cov0" title="0">{
                        cb.setState(StateHalfOpen, now)
                }</span>
        }
        <span class="cov0" title="0">return cb.state, cb.generation</span>
}

func (cb *CircuitBreaker) setState(state State, now time.Time) <span class="cov0" title="0">{
        if cb.state == state </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">prev := cb.state
        cb.state = state

        cb.toNewGeneration(now)

        if cb.onStateChange != nil </span><span class="cov0" title="0">{
                cb.onStateChange(cb.name, prev, state)
        }</span>

        <span class="cov0" title="0">cb.logger.WithFields(logrus.Fields{
                "circuit_breaker": cb.name,
                "from_state":      prev.String(),
                "to_state":        state.String(),
        }).Info("Circuit breaker state changed")</span>
}

func (cb *CircuitBreaker) toNewGeneration(now time.Time) <span class="cov0" title="0">{
        cb.generation++
        cb.counts = Counts{}

        var zero time.Time
        switch cb.state </span>{
        case StateClosed:<span class="cov0" title="0">
                if cb.interval == 0 </span><span class="cov0" title="0">{
                        cb.expiry = zero
                }</span> else<span class="cov0" title="0"> {
                        cb.expiry = now.Add(cb.interval)
                }</span>
        case StateOpen:<span class="cov0" title="0">
                cb.expiry = now.Add(cb.timeout)</span>
        default:<span class="cov0" title="0"> // StateHalfOpen
                cb.expiry = zero</span>
        }
}

func (cb *CircuitBreaker) State() State <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        now := time.Now()
        state, _ := cb.currentState(now)
        return state
}</span>

func (cb *CircuitBreaker) Counts() Counts <span class="cov0" title="0">{
        cb.mutex.Lock()
        defer cb.mutex.Unlock()

        return cb.counts
}</span>

type Manager struct {
        breakers map[string]*CircuitBreaker
        mutex    sync.RWMutex
        logger   *logrus.Logger
}

func NewManager(logger *logrus.Logger) *Manager <span class="cov0" title="0">{
        return &amp;Manager{
                breakers: make(map[string]*CircuitBreaker),
                logger:   logger,
        }
}</span>

func (m *Manager) GetBreaker(name string, config Config) *CircuitBreaker <span class="cov0" title="0">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if breaker, exists := m.breakers[name]; exists </span><span class="cov0" title="0">{
                return breaker
        }</span>

        <span class="cov0" title="0">breaker := NewCircuitBreaker(name, config, m.logger)
        m.breakers[name] = breaker
        return breaker</span>
}

func (m *Manager) GetBreakerStatus() map[string]interface{} <span class="cov0" title="0">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        status := make(map[string]interface{})
        for name, breaker := range m.breakers </span><span class="cov0" title="0">{
                status[name] = map[string]interface{}{
                        "state":  breaker.State().String(),
                        "counts": breaker.Counts(),
                }
        }</span>
        <span class="cov0" title="0">return status</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/sirupsen/logrus"
        "gopkg.in/yaml.v3"
)

type Config struct {
        Server     ServerConfig     `yaml:"server"`
        Logging    LoggingConfig    `yaml:"logging"`
        Auth       AuthConfig       `yaml:"auth"`
        RateLimit  RateLimitConfig  `yaml:"rateLimit"`
        Cache      CacheConfig      `yaml:"cache"`
        Monitoring MonitoringConfig `yaml:"monitoring"`
        Admin      AdminConfig      `yaml:"admin"`
        Services   []ServiceConfig  `yaml:"services"`
}

type ServerConfig struct {
        Port            int           `yaml:"port"`
        Timeout         time.Duration `yaml:"timeout"`
        ReadTimeout     time.Duration `yaml:"readTimeout"`
        WriteTimeout    time.Duration `yaml:"writeTimeout"`
        GracefulTimeout time.Duration `yaml:"gracefulTimeout"`
        Compression     bool          `yaml:"compression"`
}

type LoggingConfig struct {
        Level string `yaml:"level"`
        JSON  bool   `yaml:"json"`
}

type AuthConfig struct {
        JWTSecret         string        `yaml:"jwtSecret"`
        AccessTokenTTL    time.Duration `yaml:"accessTokenTTL"`
        RefreshTokenTTL   time.Duration `yaml:"refreshTokenTTL"`
        IgnorePathRegexes []string      `yaml:"ignorePathRegexes"`
}

type AdminConfig struct {
        Enabled  bool   `yaml:"enabled"`
        Username string `yaml:"username"`
        Password string `yaml:"password"`
}

type RateLimitConfig struct {
        Enabled  bool          `yaml:"enabled"`
        Limit    int           `yaml:"limit"`
        Duration time.Duration `yaml:"duration"`
        Strategy string        `yaml:"strategy"`
        RedisURL string        `yaml:"redisUrl"`
}

type CacheConfig struct {
        Enabled     bool          `yaml:"enabled"`
        TTL         time.Duration `yaml:"ttl"`
        RedisURL    string        `yaml:"redisUrl"`
        Strategy    string        `yaml:"strategy"`
        MaxSizeInMB int           `yaml:"maxSizeInMB"`
}

type MonitoringConfig struct {
        Enabled bool   `yaml:"enabled"`
        Path    string `yaml:"path"`
}

type ServiceConfig struct {
        Name           string             `yaml:"name"`
        BasePath       string             `yaml:"basePath"`
        Targets        []string           `yaml:"targets"`
        StripBasePath  bool               `yaml:"stripBasePath"`
        Timeout        time.Duration      `yaml:"timeout"`
        RetryCount     int                `yaml:"retryCount"`
        RetryDelay     time.Duration      `yaml:"retryDelay"`
        Authentication bool               `yaml:"authentication"`
        LoadBalancing  string             `yaml:"loadBalancing"`
        Headers        map[string]string  `yaml:"headers"`
        Transform      TransformConfig    `yaml:"transform"`
        Aggregation    *AggregationConfig `yaml:"aggregation,omitempty"`
}

type TransformConfig struct {
        Request  []TransformRule `yaml:"request"`
        Response []TransformRule `yaml:"response"`
}

type TransformRule struct {
        From    string `yaml:"from"`
        To      string `yaml:"to"`
        Default string `yaml:"default"`
}

type AggregationConfig struct {
        Dependencies []DependencyConfig `yaml:"dependencies"`
}

type DependencyConfig struct {
        Service          string          `yaml:"service"`
        Path             string          `yaml:"path"`
        ParameterMapping []MappingConfig `yaml:"parameterMapping"`
        ResultMapping    []MappingConfig `yaml:"resultMapping"`
}

type MappingConfig struct {
        From string `yaml:"from"`
        To   string `yaml:"to"`
}

// SetDefaults sets default values for ServiceConfig
func (s *ServiceConfig) SetDefaults() <span class="cov0" title="0">{
        if s.LoadBalancing == "" </span><span class="cov0" title="0">{
                s.LoadBalancing = "round_robin"
        }</span>
        <span class="cov0" title="0">if s.Timeout == 0 </span><span class="cov0" title="0">{
                s.Timeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if s.RetryCount == 0 </span><span class="cov0" title="0">{
                s.RetryCount = 3
        }</span>
        <span class="cov0" title="0">if s.RetryDelay == 0 </span><span class="cov0" title="0">{
                s.RetryDelay = 1 * time.Second
        }</span>
}

func Load(configPath string, logger *logrus.Logger) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file: %w", err)
        }</span>

        <span class="cov0" title="0">var config Config
        if err := yaml.Unmarshal(data, &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file: %w", err)
        }</span>

        // Set defaults
        <span class="cov0" title="0">if config.Server.Port == 0 </span><span class="cov0" title="0">{
                config.Server.Port = 8080
        }</span>
        <span class="cov0" title="0">if config.Server.ReadTimeout == 0 </span><span class="cov0" title="0">{
                config.Server.ReadTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.Server.WriteTimeout == 0 </span><span class="cov0" title="0">{
                config.Server.WriteTimeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.Server.GracefulTimeout == 0 </span><span class="cov0" title="0">{
                config.Server.GracefulTimeout = 15 * time.Second
        }</span>
        <span class="cov0" title="0">if config.Server.Timeout == 0 </span><span class="cov0" title="0">{
                config.Server.Timeout = 30 * time.Second
        }</span>

        <span class="cov0" title="0">if config.Logging.Level == "" </span><span class="cov0" title="0">{
                config.Logging.Level = "info"
        }</span>

        <span class="cov0" title="0">if config.Monitoring.Path == "" </span><span class="cov0" title="0">{
                config.Monitoring.Path = "/metrics"
        }</span>

        // Load services from external file if available
        <span class="cov0" title="0">servicesPath := filepath.Join(filepath.Dir(configPath), "services.yaml")
        if _, err := os.Stat(servicesPath); err == nil </span><span class="cov0" title="0">{
                servicesData, err := os.ReadFile(servicesPath)
                if err == nil </span><span class="cov0" title="0">{
                        var servicesConfig struct {
                                Services []ServiceConfig `yaml:"services"`
                        }
                        if err := yaml.Unmarshal(servicesData, &amp;servicesConfig); err == nil </span><span class="cov0" title="0">{
                                config.Services = append(config.Services, servicesConfig.Services...)
                        }</span>
                }
        }

        // Set defaults for services
        <span class="cov0" title="0">for i := range config.Services </span><span class="cov0" title="0">{
                config.Services[i].SetDefaults()
        }</span>

        <span class="cov0" title="0">if err := validateConfig(&amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config validation failed: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;config, nil</span>
}

func validateConfig(config *Config) error <span class="cov0" title="0">{
        if config.Server.Port &lt;= 0 || config.Server.Port &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid server port: %d", config.Server.Port)
        }</span>

        <span class="cov0" title="0">for _, service := range config.Services </span><span class="cov0" title="0">{
                if service.Name == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("service name cannot be empty")
                }</span>
                <span class="cov0" title="0">if service.BasePath == "" </span><span class="cov0" title="0">{
                        return fmt.Errorf("service %s: basePath cannot be empty", service.Name)
                }</span>
                <span class="cov0" title="0">if len(service.Targets) == 0 </span><span class="cov0" title="0">{
                        return fmt.Errorf("service %s: at least one target must be specified", service.Name)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package debug

import (
        "net/http"
        "odin/pkg/config"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

func Register(e *echo.Echo, cfg *config.Config, logger *logrus.Logger) <span class="cov0" title="0">{
        e.GET("/debug/routes", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, map[string]interface{}{
                        "services": cfg.Services,
                })
        }</span>)

        <span class="cov0" title="0">logger.Info("Debug endpoint registered at /debug/routes")</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package errors

import (
        "errors"
        "fmt"
        "net/http"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

// Standard error types
var (
        ErrNotFound           = errors.New("resource not found")
        ErrUnauthorized       = errors.New("unauthorized access")
        ErrForbidden          = errors.New("forbidden access")
        ErrBadRequest         = errors.New("bad request")
        ErrInternalServer     = errors.New("internal server error")
        ErrServiceUnavailable = errors.New("service unavailable")
        ErrTimeout            = errors.New("request timed out")
)

// HTTPError represents an error with HTTP status code and details
type HTTPError struct {
        Code    int    `json:"code"`
        Message string `json:"message"`
        Details string `json:"details,omitempty"`
}

// Error returns the error message
func (e *HTTPError) Error() string <span class="cov0" title="0">{
        if e.Details != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %s", e.Message, e.Details)
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}

// NewHTTPError creates a new HTTPError
func NewHTTPError(code int, message string, details string) *HTTPError <span class="cov0" title="0">{
        return &amp;HTTPError{
                Code:    code,
                Message: message,
                Details: details,
        }
}</span>

// StatusCodeFromError returns an appropriate HTTP status code for an error
func StatusCodeFromError(err error) int <span class="cov0" title="0">{
        var httpErr *HTTPError
        if errors.As(err, &amp;httpErr) </span><span class="cov0" title="0">{
                return httpErr.Code
        }</span>

        <span class="cov0" title="0">switch </span>{
        case errors.Is(err, ErrNotFound):<span class="cov0" title="0">
                return http.StatusNotFound</span>
        case errors.Is(err, ErrUnauthorized):<span class="cov0" title="0">
                return http.StatusUnauthorized</span>
        case errors.Is(err, ErrForbidden):<span class="cov0" title="0">
                return http.StatusForbidden</span>
        case errors.Is(err, ErrBadRequest):<span class="cov0" title="0">
                return http.StatusBadRequest</span>
        case errors.Is(err, ErrTimeout), errors.Is(err, ErrServiceUnavailable):<span class="cov0" title="0">
                return http.StatusServiceUnavailable</span>
        default:<span class="cov0" title="0">
                return http.StatusInternalServerError</span>
        }
}

// ErrorHandler creates a custom error handler for Echo
func ErrorHandler(logger *logrus.Logger) echo.HTTPErrorHandler <span class="cov0" title="0">{
        return func(err error, c echo.Context) </span><span class="cov0" title="0">{
                var he *HTTPError
                var ee *echo.HTTPError

                switch </span>{
                case errors.As(err, &amp;he):<span class="cov0" title="0">
                        logger.WithFields(logrus.Fields{
                                "method":  c.Request().Method,
                                "path":    c.Request().URL.Path,
                                "code":    he.Code,
                                "message": he.Message,
                                "details": he.Details,
                        }).Error("HTTP error occurred")

                        if err := c.JSON(he.Code, map[string]interface{}{
                                "error":   he.Message,
                                "details": he.Details,
                        }); err != nil </span><span class="cov0" title="0">{
                                logger.WithError(err).Error("Failed to write error response")
                        }</span>

                case errors.As(err, &amp;ee):<span class="cov0" title="0">
                        logger.WithFields(logrus.Fields{
                                "method":  c.Request().Method,
                                "path":    c.Request().URL.Path,
                                "code":    ee.Code,
                                "message": ee.Message,
                        }).Error("Echo HTTP error occurred")

                        if err := c.JSON(ee.Code, map[string]interface{}{
                                "error": ee.Message,
                        }); err != nil </span><span class="cov0" title="0">{
                                logger.WithError(err).Error("Failed to write error response")
                        }</span>

                default:<span class="cov0" title="0">
                        logger.WithFields(logrus.Fields{
                                "method": c.Request().Method,
                                "path":   c.Request().URL.Path,
                                "error":  err.Error(),
                        }).Error("Unhandled error occurred")

                        if err := c.JSON(http.StatusInternalServerError, map[string]interface{}{
                                "error": "Internal server error",
                        }); err != nil </span><span class="cov0" title="0">{
                                logger.WithError(err).Error("Failed to write error response")
                        }</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package health

import (
        "net/http"
        "odin/pkg/config"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

func Register(e *echo.Echo, logger *logrus.Logger) <span class="cov0" title="0">{
        e.GET("/health", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, map[string]string{
                        "status": "UP",
                })
        }</span>)

        // Add readiness endpoint
        <span class="cov0" title="0">e.GET("/ready", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, map[string]string{
                        "status": "ready",
                })
        }</span>)

        // Add liveness endpoint
        <span class="cov0" title="0">e.GET("/live", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(http.StatusOK, map[string]string{
                        "status": "alive",
                })
        }</span>)

        <span class="cov0" title="0">e.GET("/debug/routes", func(c echo.Context) error </span><span class="cov0" title="0">{
                routes := []map[string]string{}
                for _, r := range e.Routes() </span><span class="cov0" title="0">{
                        routes = append(routes, map[string]string{
                                "method": r.Method,
                                "path":   r.Path,
                        })
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusOK, routes)</span>
        })

        <span class="cov0" title="0">e.GET("/debug/config", func(c echo.Context) error </span><span class="cov0" title="0">{
                if cfg, ok := c.Get("config").(*config.Config); ok </span><span class="cov0" title="0">{
                        return c.JSON(http.StatusOK, cfg)
                }</span>
                <span class="cov0" title="0">return c.JSON(http.StatusOK, map[string]string{
                        "status": "Config not available in context",
                })</span>
        })

        <span class="cov0" title="0">e.GET("/debug/content-types", func(c echo.Context) error </span><span class="cov0" title="0">{
                testObj := map[string]interface{}{
                        "message":   "This is a JSON test message",
                        "timestamp": time.Now().Unix(),
                }

                c.Response().Header().Set("Content-Type", "application/json")
                return c.JSON(http.StatusOK, testObj)
        }</span>)

        <span class="cov0" title="0">logger.Info("Health check and debug endpoints registered")</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package logging

import (
        "time"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

func NewLogger() *logrus.Logger <span class="cov0" title="0">{
        logger := logrus.New()
        logger.SetFormatter(&amp;logrus.JSONFormatter{})
        logger.SetLevel(logrus.InfoLevel)
        return logger
}</span>

func ConfigureLogger(logger *logrus.Logger, level string, jsonFormat bool) <span class="cov0" title="0">{
        logLevel, err := logrus.ParseLevel(level)
        if err != nil </span><span class="cov0" title="0">{
                logger.Warnf("Invalid log level '%s', defaulting to 'info'", level)
                logLevel = logrus.InfoLevel
        }</span>
        <span class="cov0" title="0">logger.SetLevel(logLevel)

        if jsonFormat </span><span class="cov0" title="0">{
                logger.SetFormatter(&amp;logrus.JSONFormatter{})
        }</span> else<span class="cov0" title="0"> {
                logger.SetFormatter(&amp;logrus.TextFormatter{
                        FullTimestamp: true,
                })
        }</span>
}

func LoggerMiddleware(logger *logrus.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        start := time.Now()
                        req := c.Request()

                        err := next(c)

                        res := c.Response()
                        latency := time.Since(start)

                        fields := logrus.Fields{
                                "method":     req.Method,
                                "uri":        req.RequestURI,
                                "status":     res.Status,
                                "latency_ms": latency.Milliseconds(),
                                "user_agent": req.UserAgent(),
                                "ip":         c.RealIP(),
                        }

                        if err != nil </span><span class="cov0" title="0">{
                                fields["error"] = err.Error()
                                logger.WithFields(fields).Error("Request error")
                        }</span> else<span class="cov0" title="0"> {
                                logger.WithFields(fields).Info("Request processed")
                        }</span>

                        <span class="cov0" title="0">return err</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package middleware

import (
        "time"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

func LoggerMiddleware(logger *logrus.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        start := time.Now()
                        req := c.Request()

                        err := next(c)

                        res := c.Response()
                        latency := time.Since(start)

                        fields := logrus.Fields{
                                "method":     req.Method,
                                "uri":        req.RequestURI,
                                "status":     res.Status,
                                "latency_ms": latency.Milliseconds(),
                                "user_agent": req.UserAgent(),
                                "ip":         c.RealIP(),
                        }

                        if err != nil </span><span class="cov0" title="0">{
                                fields["error"] = err.Error()
                                logger.WithFields(fields).Error("Request error")
                        }</span> else<span class="cov0" title="0"> {
                                logger.WithFields(fields).Info("Request processed")
                        }</span>

                        <span class="cov0" title="0">return err</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package middleware

import (
        "crypto/sha256"
        "encoding/hex"
        "io"
        "net/http"
        "odin/pkg/cache"
        "odin/pkg/ratelimit"
        "strings"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

func RateLimiterMiddleware(limiter ratelimit.RateLimiter, logger *logrus.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        key := c.RealIP()

                        if user, ok := c.Get("user").(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                if userID, exists := user["user_id"].(string); exists &amp;&amp; userID != "" </span><span class="cov0" title="0">{
                                        key = userID
                                }</span>
                        }

                        <span class="cov0" title="0">if !limiter.Allow(key) </span><span class="cov0" title="0">{
                                logger.WithFields(logrus.Fields{
                                        "ip":  c.RealIP(),
                                        "uri": c.Request().RequestURI,
                                }).Warn("Rate limit exceeded")
                                return echo.NewHTTPError(http.StatusTooManyRequests, "Rate limit exceeded")
                        }</span>

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

func CacheMiddleware(store cache.Store, logger *logrus.Logger) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        req := c.Request()

                        if req.Method != http.MethodGet </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov0" title="0">key := generateCacheKey(c)

                        if cachedData, found := store.Get(key); found </span><span class="cov0" title="0">{
                                if cacheEntry, ok := cachedData.(*cache.CacheEntry); ok </span><span class="cov0" title="0">{
                                        logger.WithFields(logrus.Fields{
                                                "uri": req.RequestURI,
                                                "key": key,
                                        }).Debug("Cache hit")

                                        for k, v := range cacheEntry.Headers </span><span class="cov0" title="0">{
                                                c.Response().Header().Set(k, v)
                                        }</span>
                                        <span class="cov0" title="0">c.Response().WriteHeader(cacheEntry.StatusCode)
                                        _, err := c.Response().Write(cacheEntry.Data)
                                        return err</span>
                                }
                        }

                        <span class="cov0" title="0">resWriter := &amp;responseWriterWrapper{
                                ResponseWriter: c.Response().Writer,
                                statusCode:     http.StatusOK,
                                body:           strings.Builder{},
                                headers:        make(http.Header),
                        }
                        c.Response().Writer = resWriter

                        err := next(c)

                        if err == nil </span><span class="cov0" title="0">{
                                cacheEntry := &amp;cache.CacheEntry{
                                        Headers:    make(map[string]string),
                                        StatusCode: resWriter.statusCode,
                                        Data:       []byte(resWriter.body.String()),
                                }

                                for k, v := range resWriter.headers </span><span class="cov0" title="0">{
                                        if len(v) &gt; 0 </span><span class="cov0" title="0">{
                                                cacheEntry.Headers[k] = v[0]
                                        }</span>
                                }

                                <span class="cov0" title="0">store.Set(key, cacheEntry, 0) // TTL handled by store

                                logger.WithFields(logrus.Fields{
                                        "uri": req.RequestURI,
                                        "key": key,
                                }).Debug("Cached response")</span>
                        }

                        <span class="cov0" title="0">return err</span>
                }
        }
}

type responseWriterWrapper struct {
        http.ResponseWriter
        statusCode int
        body       strings.Builder
        headers    http.Header
}

func (w *responseWriterWrapper) WriteHeader(statusCode int) <span class="cov0" title="0">{
        w.statusCode = statusCode
        w.ResponseWriter.WriteHeader(statusCode)
}</span>

func (w *responseWriterWrapper) Write(b []byte) (int, error) <span class="cov0" title="0">{
        w.body.Write(b)
        return w.ResponseWriter.Write(b)
}</span>

func (w *responseWriterWrapper) Header() http.Header <span class="cov0" title="0">{
        return w.ResponseWriter.Header()
}</span>

func generateCacheKey(c echo.Context) string <span class="cov0" title="0">{
        req := c.Request()

        keyParts := []string{req.Method, req.URL.Path, req.URL.RawQuery}

        if req.Body != nil &amp;&amp; (req.Method == http.MethodPost || req.Method == http.MethodPut) </span><span class="cov0" title="0">{
                if req.ContentLength &gt; 0 &amp;&amp; req.ContentLength &lt; 1024*10 </span><span class="cov0" title="0">{
                        bodyBytes, err := io.ReadAll(req.Body)
                        if err == nil </span><span class="cov0" title="0">{
                                req.Body = io.NopCloser(strings.NewReader(string(bodyBytes)))
                                keyParts = append(keyParts, string(bodyBytes))
                        }</span>
                }
        }

        <span class="cov0" title="0">hasher := sha256.New()
        hasher.Write([]byte(strings.Join(keyParts, "|")))
        return hex.EncodeToString(hasher.Sum(nil))</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package monitoring

import (
        "net/http"
        "strconv"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"
        "github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
        requestCounter = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "api_gateway_requests_total",
                        Help: "Total number of requests processed by the API gateway",
                },
                []string{"service", "method", "status"},
        )

        requestDuration = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "api_gateway_request_duration_seconds",
                        Help:    "Request duration in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"service", "method"},
        )

        responseSizes = promauto.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "api_gateway_response_size_bytes",
                        Help:    "Response size in bytes",
                        Buckets: prometheus.ExponentialBuckets(100, 10, 8),
                },
                []string{"service"},
        )

        activeRequests = promauto.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "api_gateway_active_requests",
                        Help: "Currently active requests",
                },
                []string{"service"},
        )

        cacheHits = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "api_gateway_cache_hits_total",
                        Help: "Total number of cache hits",
                },
                []string{"service"},
        )

        cacheMisses = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "api_gateway_cache_misses_total",
                        Help: "Total number of cache misses",
                },
                []string{"service"},
        )

        rateLimited = promauto.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "api_gateway_rate_limited_total",
                        Help: "Total number of rate limited requests",
                },
                []string{"service"},
        )
)

func Register(e *echo.Echo, path string) <span class="cov0" title="0">{
        e.GET(path, echo.WrapHandler(promhttp.Handler()))
        e.Use(MetricsMiddleware)
}</span>

func MetricsMiddleware(next echo.HandlerFunc) echo.HandlerFunc <span class="cov0" title="0">{
        return func(c echo.Context) error </span><span class="cov0" title="0">{
                path := c.Request().URL.Path
                service := "unknown"

                parts := splitPath(path)
                if len(parts) &gt; 1 </span><span class="cov0" title="0">{
                        service = parts[1]
                }</span>

                <span class="cov0" title="0">activeRequests.WithLabelValues(service).Inc()
                defer activeRequests.WithLabelValues(service).Dec()

                start := time.Now()

                err := next(c)

                duration := time.Since(start).Seconds()
                status := strconv.Itoa(c.Response().Status)

                requestCounter.WithLabelValues(service, c.Request().Method, status).Inc()
                requestDuration.WithLabelValues(service, c.Request().Method).Observe(duration)

                if c.Response().Size &gt; 0 </span><span class="cov0" title="0">{
                        responseSizes.WithLabelValues(service).Observe(float64(c.Response().Size))
                }</span>

                <span class="cov0" title="0">if c.Response().Status == http.StatusTooManyRequests </span><span class="cov0" title="0">{
                        rateLimited.WithLabelValues(service).Inc()
                }</span>

                <span class="cov0" title="0">if c.Response().Header().Get("X-Cache") == "HIT" </span><span class="cov0" title="0">{
                        cacheHits.WithLabelValues(service).Inc()
                }</span> else<span class="cov0" title="0"> if c.Response().Header().Get("X-Cache") == "MISS" </span><span class="cov0" title="0">{
                        cacheMisses.WithLabelValues(service).Inc()
                }</span>

                <span class="cov0" title="0">return err</span>
        }
}

func splitPath(path string) []string <span class="cov0" title="0">{
        var parts []string
        start := 0
        for i := 0; i &lt; len(path); i++ </span><span class="cov0" title="0">{
                if path[i] == '/' </span><span class="cov0" title="0">{
                        if start &lt; i </span><span class="cov0" title="0">{
                                parts = append(parts, path[start:i])
                        }</span>
                        <span class="cov0" title="0">parts = append(parts, "/")
                        start = i + 1</span>
                }
        }
        <span class="cov0" title="0">if start &lt; len(path) </span><span class="cov0" title="0">{
                parts = append(parts, path[start:])
        }</span>
        <span class="cov0" title="0">return parts</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package ratelimit

import (
        "context"
        "crypto/md5"
        "fmt"
        "net"
        "net/http"
        "strconv"
        "strings"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/redis/go-redis/v9"
        "github.com/sirupsen/logrus"
)

type Algorithm string

const (
        AlgorithmTokenBucket   Algorithm = "token_bucket"
        AlgorithmSlidingWindow Algorithm = "sliding_window"
        AlgorithmFixedWindow   Algorithm = "fixed_window"
        AlgorithmLeakyBucket   Algorithm = "leaky_bucket"
)

type Config struct {
        Enabled          bool          `yaml:"enabled"`
        Algorithm        Algorithm     `yaml:"algorithm"`
        DefaultLimit     int           `yaml:"defaultLimit"`
        DefaultWindow    time.Duration `yaml:"defaultWindow"`
        BurstSize        int           `yaml:"burstSize"`
        Redis            RedisConfig   `yaml:"redis"`
        Rules            []Rule        `yaml:"rules"`
        SkipPaths        []string      `yaml:"skipPaths"`
        TrustedProxies   []string      `yaml:"trustedProxies"`
        HeadersToInclude []string      `yaml:"headersToInclude"`
        CustomKeyFunc    string        `yaml:"customKeyFunc"`
        ResponseHeaders  bool          `yaml:"responseHeaders"`
        LogViolations    bool          `yaml:"logViolations"`
}

type RedisConfig struct {
        Address  string `yaml:"address"`
        Password string `yaml:"password"`
        DB       int    `yaml:"db"`
}

type Rule struct {
        Name        string        `yaml:"name"`
        Path        string        `yaml:"path"`
        Method      string        `yaml:"method"`
        Limit       int           `yaml:"limit"`
        Window      time.Duration `yaml:"window"`
        BurstSize   int           `yaml:"burstSize"`
        UserTypes   []string      `yaml:"userTypes"`
        APIKeys     []string      `yaml:"apiKeys"`
        IPWhitelist []string      `yaml:"ipWhitelist"`
        IPBlacklist []string      `yaml:"ipBlacklist"`
        Headers     []HeaderRule  `yaml:"headers"`
        SkipAuth    bool          `yaml:"skipAuth"`
}

type HeaderRule struct {
        Name  string `yaml:"name"`
        Value string `yaml:"value"`
}

type KeyType string

const (
        KeyTypeIP     KeyType = "ip"
        KeyTypeUser   KeyType = "user"
        KeyTypeAPIKey KeyType = "api_key"
        KeyTypeCustom KeyType = "custom"
)

type Limiter struct {
        config      Config
        redisClient *redis.Client
        logger      *logrus.Logger
        rules       map[string]Rule
}

type LimitInfo struct {
        Key       string        `json:"key"`
        Limit     int           `json:"limit"`
        Remaining int           `json:"remaining"`
        ResetTime time.Time     `json:"reset_time"`
        Window    time.Duration `json:"window"`
}

type RateLimiter interface {
        Allow(key string) bool
        CheckLimit(ctx context.Context, key string, rule *Rule) (*LimitInfo, bool)
        Middleware() echo.MiddlewareFunc
}

func NewLimiter(config Config, logger *logrus.Logger) (*Limiter, error) <span class="cov0" title="0">{
        var redisClient *redis.Client

        if config.Redis.Address != "" </span><span class="cov0" title="0">{
                redisClient = redis.NewClient(&amp;redis.Options{
                        Addr:     config.Redis.Address,
                        Password: config.Redis.Password,
                        DB:       config.Redis.DB,
                })

                ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                defer cancel()

                if err := redisClient.Ping(ctx).Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to connect to Redis: %w", err)
                }</span>
        }

        <span class="cov0" title="0">rules := make(map[string]Rule)
        for _, rule := range config.Rules </span><span class="cov0" title="0">{
                key := fmt.Sprintf("%s:%s", rule.Method, rule.Path)
                rules[key] = rule
        }</span>

        <span class="cov0" title="0">return &amp;Limiter{
                config:      config,
                redisClient: redisClient,
                logger:      logger,
                rules:       rules,
        }, nil</span>
}

func (l *Limiter) Middleware() echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        if !l.config.Enabled </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov0" title="0">if l.shouldSkip(c) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov0" title="0">rule := l.findRule(c)
                        if rule == nil </span><span class="cov0" title="0">{
                                rule = &amp;Rule{
                                        Limit:  l.config.DefaultLimit,
                                        Window: l.config.DefaultWindow,
                                }
                        }</span>

                        <span class="cov0" title="0">if l.isWhitelisted(c, rule) </span><span class="cov0" title="0">{
                                return next(c)
                        }</span>

                        <span class="cov0" title="0">if l.isBlacklisted(c, rule) </span><span class="cov0" title="0">{
                                return echo.NewHTTPError(http.StatusForbidden, "IP address is blacklisted")
                        }</span>

                        <span class="cov0" title="0">key := l.generateKey(c, rule)
                        limitInfo, allowed := l.checkLimit(c.Request().Context(), key, rule)

                        if l.config.ResponseHeaders </span><span class="cov0" title="0">{
                                l.setHeaders(c, limitInfo)
                        }</span>

                        <span class="cov0" title="0">if !allowed </span><span class="cov0" title="0">{
                                if l.config.LogViolations </span><span class="cov0" title="0">{
                                        l.logger.WithFields(logrus.Fields{
                                                "key":       key,
                                                "limit":     limitInfo.Limit,
                                                "remaining": limitInfo.Remaining,
                                                "ip":        l.getClientIP(c),
                                                "path":      c.Request().URL.Path,
                                                "method":    c.Request().Method,
                                        }).Warn("Rate limit exceeded")
                                }</span>

                                <span class="cov0" title="0">return echo.NewHTTPError(http.StatusTooManyRequests, "Rate limit exceeded")</span>
                        }

                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

func (l *Limiter) shouldSkip(c echo.Context) bool <span class="cov0" title="0">{
        path := c.Request().URL.Path

        for _, skipPath := range l.config.SkipPaths </span><span class="cov0" title="0">{
                if strings.HasPrefix(path, skipPath) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (l *Limiter) findRule(c echo.Context) *Rule <span class="cov0" title="0">{
        method := c.Request().Method
        path := c.Request().URL.Path

        key := fmt.Sprintf("%s:%s", method, path)
        if rule, exists := l.rules[key]; exists </span><span class="cov0" title="0">{
                return &amp;rule
        }</span>

        <span class="cov0" title="0">for _, rule := range l.config.Rules </span><span class="cov0" title="0">{
                if l.MatchesRule(c, &amp;rule) </span><span class="cov0" title="0">{
                        return &amp;rule
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (l *Limiter) MatchesRule(c echo.Context, rule *Rule) bool <span class="cov0" title="0">{
        if rule.Method != "" &amp;&amp; rule.Method != c.Request().Method </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if rule.Path != "" &amp;&amp; !strings.HasPrefix(c.Request().URL.Path, rule.Path) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, headerRule := range rule.Headers </span><span class="cov0" title="0">{
                headerValue := c.Request().Header.Get(headerRule.Name)
                if headerValue != headerRule.Value </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}

func (l *Limiter) isWhitelisted(c echo.Context, rule *Rule) bool <span class="cov0" title="0">{
        clientIP := l.getClientIP(c)

        for _, whiteIP := range rule.IPWhitelist </span><span class="cov0" title="0">{
                if l.MatchesIP(clientIP, whiteIP) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (l *Limiter) isBlacklisted(c echo.Context, rule *Rule) bool <span class="cov0" title="0">{
        clientIP := l.getClientIP(c)

        for _, blackIP := range rule.IPBlacklist </span><span class="cov0" title="0">{
                if l.MatchesIP(clientIP, blackIP) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (l *Limiter) MatchesIP(clientIP, ruleIP string) bool <span class="cov0" title="0">{
        if strings.Contains(ruleIP, "/") </span><span class="cov0" title="0">{
                _, network, err := net.ParseCIDR(ruleIP)
                if err != nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">ip := net.ParseIP(clientIP)
                return network.Contains(ip)</span>
        }

        <span class="cov0" title="0">return clientIP == ruleIP</span>
}

func (l *Limiter) generateKey(c echo.Context, rule *Rule) string <span class="cov0" title="0">{
        var keyParts []string

        if apiKey := c.Request().Header.Get("X-API-Key"); apiKey != "" </span><span class="cov0" title="0">{
                keyParts = append(keyParts, "api_key:"+apiKey)
        }</span> else<span class="cov0" title="0"> if userID := l.getUserID(c); userID != "" </span><span class="cov0" title="0">{
                keyParts = append(keyParts, "user:"+userID)
        }</span> else<span class="cov0" title="0"> {
                keyParts = append(keyParts, "ip:"+l.getClientIP(c))
        }</span>

        <span class="cov0" title="0">keyParts = append(keyParts, rule.Path)
        keyParts = append(keyParts, rule.Method)

        for _, header := range l.config.HeadersToInclude </span><span class="cov0" title="0">{
                value := c.Request().Header.Get(header)
                if value != "" </span><span class="cov0" title="0">{
                        keyParts = append(keyParts, fmt.Sprintf("%s:%s", header, value))
                }</span>
        }

        <span class="cov0" title="0">key := strings.Join(keyParts, ":")
        hash := md5.Sum([]byte(key))
        return fmt.Sprintf("ratelimit:%x", hash)</span>
}

func (l *Limiter) getClientIP(c echo.Context) string <span class="cov0" title="0">{
        if l.isTrustedProxy(c.RealIP()) </span><span class="cov0" title="0">{
                if xff := c.Request().Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                        ips := strings.Split(xff, ",")
                        return strings.TrimSpace(ips[0])
                }</span>
                <span class="cov0" title="0">if xri := c.Request().Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                        return xri
                }</span>
        }

        <span class="cov0" title="0">return c.RealIP()</span>
}

func (l *Limiter) isTrustedProxy(ip string) bool <span class="cov0" title="0">{
        for _, trustedIP := range l.config.TrustedProxies </span><span class="cov0" title="0">{
                if l.MatchesIP(ip, trustedIP) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (l *Limiter) getUserID(c echo.Context) string <span class="cov0" title="0">{
        if user := c.Get("user"); user != nil </span><span class="cov0" title="0">{
                if userMap, ok := user.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                        if userID, exists := userMap["user_id"]; exists </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%v", userID)
                        }</span>
                }
        }

        <span class="cov0" title="0">return ""</span>
}

func (l *Limiter) CheckLimit(ctx context.Context, key string, rule *Rule) (*LimitInfo, bool) <span class="cov0" title="0">{
        limit := rule.Limit
        window := rule.Window

        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = l.config.DefaultLimit
        }</span>
        <span class="cov0" title="0">if window &lt;= 0 </span><span class="cov0" title="0">{
                window = l.config.DefaultWindow
        }</span>

        <span class="cov0" title="0">switch l.config.Algorithm </span>{
        case AlgorithmSlidingWindow:<span class="cov0" title="0">
                return l.checkSlidingWindow(ctx, key, limit, window)</span>
        case AlgorithmFixedWindow:<span class="cov0" title="0">
                return l.checkFixedWindow(ctx, key, limit, window)</span>
        case AlgorithmTokenBucket:<span class="cov0" title="0">
                return l.checkTokenBucket(ctx, key, limit, window, rule.BurstSize)</span>
        default:<span class="cov0" title="0">
                return l.checkFixedWindow(ctx, key, limit, window)</span>
        }
}

func (l *Limiter) checkFixedWindow(ctx context.Context, key string, limit int, window time.Duration) (*LimitInfo, bool) <span class="cov0" title="0">{
        if l.redisClient == nil </span><span class="cov0" title="0">{
                // For local testing without Redis, we'll always allow requests
                // In a real implementation, you'd use local storage
                return &amp;LimitInfo{
                        Key:       key,
                        Limit:     limit,
                        Remaining: limit - 1,
                        ResetTime: time.Now().Add(window),
                        Window:    window,
                }, true
        }</span>

        <span class="cov0" title="0">windowKey := fmt.Sprintf("%s:%d", key, time.Now().Unix()/int64(window.Seconds()))

        pipe := l.redisClient.Pipeline()
        incrCmd := pipe.Incr(ctx, windowKey)
        pipe.Expire(ctx, windowKey, window)

        _, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                l.logger.WithError(err).Error("Redis pipeline execution failed")
                return &amp;LimitInfo{Key: key, Limit: limit, Remaining: 0}, false
        }</span>

        <span class="cov0" title="0">count := int(incrCmd.Val())
        remaining := limit - count
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>

        <span class="cov0" title="0">resetTime := time.Now().Add(window)

        return &amp;LimitInfo{
                Key:       key,
                Limit:     limit,
                Remaining: remaining,
                ResetTime: resetTime,
                Window:    window,
        }, count &lt;= limit</span>
}

func (l *Limiter) checkSlidingWindow(ctx context.Context, key string, limit int, window time.Duration) (*LimitInfo, bool) <span class="cov0" title="0">{
        if l.redisClient == nil </span><span class="cov0" title="0">{
                return &amp;LimitInfo{
                        Key:       key,
                        Limit:     limit,
                        Remaining: limit - 1,
                        ResetTime: time.Now().Add(window),
                        Window:    window,
                }, true
        }</span>

        <span class="cov0" title="0">now := time.Now()
        windowStart := now.Add(-window)

        pipe := l.redisClient.Pipeline()
        pipe.ZRemRangeByScore(ctx, key, "0", strconv.FormatInt(windowStart.UnixNano(), 10))
        countCmd := pipe.ZCard(ctx, key)
        pipe.ZAdd(ctx, key, redis.Z{Score: float64(now.UnixNano()), Member: now.UnixNano()})
        pipe.Expire(ctx, key, window+time.Minute)

        _, err := pipe.Exec(ctx)
        if err != nil </span><span class="cov0" title="0">{
                l.logger.WithError(err).Error("Redis pipeline execution failed")
                return &amp;LimitInfo{Key: key, Limit: limit, Remaining: 0}, false
        }</span>

        <span class="cov0" title="0">count := int(countCmd.Val())
        remaining := limit - count - 1
        if remaining &lt; 0 </span><span class="cov0" title="0">{
                remaining = 0
        }</span>

        <span class="cov0" title="0">return &amp;LimitInfo{
                Key:       key,
                Limit:     limit,
                Remaining: remaining,
                ResetTime: now.Add(window),
                Window:    window,
        }, count &lt; limit</span>
}

func (l *Limiter) checkTokenBucket(ctx context.Context, key string, limit int, window time.Duration, burstSize int) (*LimitInfo, bool) <span class="cov0" title="0">{
        if burstSize &lt;= 0 </span><span class="cov0" title="0">{
                burstSize = l.config.BurstSize
        }</span>
        <span class="cov0" title="0">if burstSize &lt;= 0 </span><span class="cov0" title="0">{
                burstSize = limit
        }</span>

        <span class="cov0" title="0">return l.checkFixedWindow(ctx, key, burstSize, window)</span>
}

func (l *Limiter) setHeaders(c echo.Context, limitInfo *LimitInfo) <span class="cov0" title="0">{
        c.Response().Header().Set("X-RateLimit-Limit", strconv.Itoa(limitInfo.Limit))
        c.Response().Header().Set("X-RateLimit-Remaining", strconv.Itoa(limitInfo.Remaining))
        c.Response().Header().Set("X-RateLimit-Reset", strconv.FormatInt(limitInfo.ResetTime.Unix(), 10))
        c.Response().Header().Set("X-RateLimit-Window", limitInfo.Window.String())
}</span>

func (l *Limiter) Close() error <span class="cov0" title="0">{
        if l.redisClient != nil </span><span class="cov0" title="0">{
                return l.redisClient.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (l *Limiter) checkLimit(ctx context.Context, key string, rule *Rule) (*LimitInfo, bool) <span class="cov0" title="0">{
        return l.CheckLimit(ctx, key, rule)
}</span>

func (l *Limiter) GenerateKey(c echo.Context, rule *Rule) string <span class="cov0" title="0">{
        return l.generateKey(c, rule)
}</span>

func (l *Limiter) Allow(key string) bool <span class="cov0" title="0">{
        rule := &amp;Rule{
                Limit:  l.config.DefaultLimit,
                Window: l.config.DefaultWindow,
        }

        _, allowed := l.checkLimit(context.Background(), key, rule)
        return allowed
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package routing

import (
        "bytes"
        "context"
        "fmt"
        "io"
        "net/http"
        "odin/pkg/cache"
        "odin/pkg/service"
        "strings"
        "sync/atomic"
        "time"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

type ServiceHandler struct {
        service    *service.Config
        logger     *logrus.Logger
        cacheStore cache.Store
        client     *http.Client
        nextTarget uint64
}

func NewServiceHandler(svc *service.Config, logger *logrus.Logger, cacheStore cache.Store) (*ServiceHandler, error) <span class="cov0" title="0">{
        if len(svc.Targets) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("service %s has no targets", svc.Name)
        }</span>

        <span class="cov0" title="0">client := &amp;http.Client{
                Timeout: svc.Timeout,
        }

        return &amp;ServiceHandler{
                service:    svc,
                logger:     logger,
                cacheStore: cacheStore,
                client:     client,
                nextTarget: 0,
        }, nil</span>
}

func (h *ServiceHandler) Handle(c echo.Context) error <span class="cov0" title="0">{
        ctx := c.Request().Context()

        target := h.getTargetURL()
        path := c.Request().URL.Path

        if h.service.StripBasePath &amp;&amp; strings.HasPrefix(path, h.service.BasePath) </span><span class="cov0" title="0">{
                path = strings.TrimPrefix(path, h.service.BasePath)
                if path == "" </span><span class="cov0" title="0">{
                        path = "/"
                }</span>
        }

        <span class="cov0" title="0">targetURL := target + path
        if c.Request().URL.RawQuery != "" </span><span class="cov0" title="0">{
                targetURL += "?" + c.Request().URL.RawQuery
        }</span>

        <span class="cov0" title="0">h.logger.WithFields(logrus.Fields{
                "service": h.service.Name,
                "target":  targetURL,
                "method":  c.Request().Method,
        }).Debug("Forwarding request")

        req, err := h.createProxyRequest(c, targetURL)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to create proxy request")
        }</span>

        <span class="cov0" title="0">resp, err := h.doRequestWithRetries(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusBadGateway, "Service unavailable")
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        for k, vals := range resp.Header </span><span class="cov0" title="0">{
                for _, v := range vals </span><span class="cov0" title="0">{
                        c.Response().Header().Add(k, v)
                }</span>
        }

        <span class="cov0" title="0">body, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return echo.NewHTTPError(http.StatusInternalServerError, "Failed to read response body")
        }</span>

        <span class="cov0" title="0">if h.service.Aggregation != nil </span><span class="cov0" title="0">{
                // Initialize aggregation handler
                h.logger.Debug("Aggregation config found but not processed yet")
        }</span>

        <span class="cov0" title="0">c.Response().WriteHeader(resp.StatusCode)
        _, err = c.Response().Write(body)
        return err</span>
}

func (h *ServiceHandler) getTargetURL() string <span class="cov0" title="0">{
        if len(h.service.Targets) == 1 </span><span class="cov0" title="0">{
                return h.service.Targets[0]
        }</span>

        <span class="cov0" title="0">switch h.service.LoadBalancing </span>{
        case "random":<span class="cov0" title="0">
                idx := time.Now().UnixNano() % int64(len(h.service.Targets))
                return h.service.Targets[idx]</span>
        default:<span class="cov0" title="0">
                idx := atomic.AddUint64(&amp;h.nextTarget, 1) % uint64(len(h.service.Targets))
                return h.service.Targets[idx]</span>
        }
}

func (h *ServiceHandler) createProxyRequest(c echo.Context, targetURL string) (*http.Request, error) <span class="cov0" title="0">{
        var body io.Reader = nil

        if c.Request().Body != nil </span><span class="cov0" title="0">{
                bodyBytes, err := io.ReadAll(c.Request().Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">c.Request().Body = io.NopCloser(bytes.NewReader(bodyBytes))
                body = bytes.NewReader(bodyBytes)</span>
        }

        <span class="cov0" title="0">req, err := http.NewRequest(c.Request().Method, targetURL, body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for k, vals := range c.Request().Header </span><span class="cov0" title="0">{
                for _, v := range vals </span><span class="cov0" title="0">{
                        req.Header.Add(k, v)
                }</span>
        }

        <span class="cov0" title="0">for k, v := range h.service.Headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov0" title="0">return req, nil</span>
}

func (h *ServiceHandler) doRequestWithRetries(ctx context.Context, req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        var resp *http.Response
        var err error

        for i := 0; i &lt;= h.service.RetryCount; i++ </span><span class="cov0" title="0">{
                resp, err = h.client.Do(req.WithContext(ctx))
                if err == nil </span><span class="cov0" title="0">{
                        return resp, nil
                }</span>

                <span class="cov0" title="0">if i &lt; h.service.RetryCount </span><span class="cov0" title="0">{
                        h.logger.WithError(err).Warnf("Request to %s failed, retrying (%d/%d)",
                                req.URL.String(), i+1, h.service.RetryCount)
                        time.Sleep(h.service.RetryDelay)

                        body, _ := io.ReadAll(req.Body)
                        req.Body = io.NopCloser(bytes.NewReader(body))
                }</span>
        }

        <span class="cov0" title="0">return nil, err</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package routing

import (
        "odin/pkg/cache"
        "odin/pkg/service"

        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

type Router struct {
        echo           *echo.Echo
        registry       *service.Registry
        logger         *logrus.Logger
        cacheStore     cache.Store
        authMiddleware echo.MiddlewareFunc
}

func NewRouter(e *echo.Echo, registry *service.Registry, logger *logrus.Logger) *Router <span class="cov0" title="0">{
        return &amp;Router{
                echo:     e,
                registry: registry,
                logger:   logger,
        }
}</span>

func (r *Router) SetCacheStore(store cache.Store) <span class="cov0" title="0">{
        r.cacheStore = store
}</span>

func (r *Router) SetAuthMiddleware(middleware echo.MiddlewareFunc) <span class="cov0" title="0">{
        r.authMiddleware = middleware
}</span>

func (r *Router) RegisterRoutes() error <span class="cov0" title="0">{
        // Register service routes
        services := r.registry.GetAllServices()

        for _, svc := range services </span><span class="cov0" title="0">{
                r.logger.WithFields(logrus.Fields{
                        "name":     svc.Name,
                        "basePath": svc.BasePath,
                }).Info("Registering service route")

                // Create service handler
                handler, err := NewServiceHandler(svc, r.logger, r.cacheStore)
                if err != nil </span><span class="cov0" title="0">{
                        r.logger.WithError(err).Warnf("Failed to create handler for service %s", svc.Name)
                        continue</span>
                }

                // Create route group
                <span class="cov0" title="0">group := r.echo.Group(svc.BasePath)

                // Apply authentication middleware if required
                if svc.Authentication &amp;&amp; r.authMiddleware != nil </span><span class="cov0" title="0">{
                        group.Use(r.authMiddleware)
                }</span>

                // Register routes
                <span class="cov0" title="0">group.Any("", handler.Handle)
                group.Any("/*", handler.Handle)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (r *Router) RegisterHealthRoutes() <span class="cov0" title="0">{
        r.echo.GET("/health", func(c echo.Context) error </span><span class="cov0" title="0">{
                return c.JSON(200, map[string]string{
                        "status": "UP",
                })
        }</span>)

        <span class="cov0" title="0">r.echo.GET("/routes", func(c echo.Context) error </span><span class="cov0" title="0">{
                var routes []map[string]string
                for _, route := range r.echo.Routes() </span><span class="cov0" title="0">{
                        routes = append(routes, map[string]string{
                                "method": route.Method,
                                "path":   route.Path,
                        })
                }</span>
                <span class="cov0" title="0">return c.JSON(200, routes)</span>
        })
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package service

import (
        "fmt"
        "os"
        "time"

        "github.com/sirupsen/logrus"
        "gopkg.in/yaml.v3"
)

type ServiceConfig struct {
        Services []Config `yaml:"services"`
}

func LoadServices(configPath string, logger *logrus.Logger) ([]Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(configPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read services config file: %w", err)
        }</span>

        <span class="cov0" title="0">var serviceConfig ServiceConfig
        if err := yaml.Unmarshal(data, &amp;serviceConfig); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse services config file: %w", err)
        }</span>

        // Set defaults for each service
        <span class="cov0" title="0">for i := range serviceConfig.Services </span><span class="cov0" title="0">{
                setServiceDefaults(&amp;serviceConfig.Services[i])
        }</span>

        <span class="cov0" title="0">logger.WithField("count", len(serviceConfig.Services)).Info("Loaded services configuration")

        return serviceConfig.Services, nil</span>
}

func setServiceDefaults(config *Config) <span class="cov0" title="0">{
        if config.Timeout == 0 </span><span class="cov0" title="0">{
                config.Timeout = 30 * time.Second
        }</span>
        <span class="cov0" title="0">if config.RetryCount == 0 </span><span class="cov0" title="0">{
                config.RetryCount = 3
        }</span>
        <span class="cov0" title="0">if config.RetryDelay == 0 </span><span class="cov0" title="0">{
                config.RetryDelay = 1 * time.Second
        }</span>
        <span class="cov0" title="0">if config.LoadBalancing == "" </span><span class="cov0" title="0">{
                config.LoadBalancing = "round_robin"
        }</span>
}

func ValidateService(config *Config) error <span class="cov0" title="0">{
        if config.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service name cannot be empty")
        }</span>
        <span class="cov0" title="0">if config.BasePath == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service basePath cannot be empty")
        }</span>
        <span class="cov0" title="0">if len(config.Targets) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("service must have at least one target")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package service

import (
        "fmt"
        "strings"
        "time"

        "github.com/sirupsen/logrus"
)

type Config struct {
        Name           string            `yaml:"name"`
        BasePath       string            `yaml:"basePath"`
        Targets        []string          `yaml:"targets"`
        StripBasePath  bool              `yaml:"stripBasePath"`
        Timeout        time.Duration     `yaml:"timeout"`
        RetryCount     int               `yaml:"retryCount"`
        RetryDelay     time.Duration     `yaml:"retryDelay"`
        Authentication bool              `yaml:"authentication"`
        LoadBalancing  string            `yaml:"loadBalancing"`
        Headers        map[string]string `yaml:"headers"`
        Transform      struct {
                Request  []TransformRule `yaml:"request"`
                Response []TransformRule `yaml:"response"`
        } `yaml:"transform"`
        Aggregation *AggregationConfig `yaml:"aggregation,omitempty"`
}

type AggregationConfig struct {
        Dependencies []DependencyConfig `yaml:"dependencies"`
}

type DependencyConfig struct {
        Service          string          `yaml:"service"`
        Path             string          `yaml:"path"`
        ParameterMapping []MappingConfig `yaml:"parameterMapping"`
        ResultMapping    []MappingConfig `yaml:"resultMapping"`
}

type MappingConfig struct {
        From string `yaml:"from"`
        To   string `yaml:"to"`
}

type TransformRule struct {
        From    string `yaml:"from"`
        To      string `yaml:"to"`
        Default string `yaml:"default"`
}

func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

type Registry struct {
        services map[string]*Config
        logger   *logrus.Logger
}

func NewRegistry(logger *logrus.Logger) *Registry <span class="cov0" title="0">{
        return &amp;Registry{
                services: make(map[string]*Config),
                logger:   logger,
        }
}</span>

func (r *Registry) Register(svc *Config) error <span class="cov0" title="0">{
        if svc.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("service name cannot be empty")
        }</span>

        <span class="cov0" title="0">if _, exists := r.services[svc.Name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("service %s already registered", svc.Name)
        }</span>

        <span class="cov0" title="0">r.services[svc.Name] = svc
        r.logger.WithFields(logrus.Fields{
                "name":           svc.Name,
                "base_path":      svc.BasePath,
                "targets":        svc.Targets,
                "authentication": svc.Authentication,
        }).Info("Service registered")

        return nil</span>
}

func (r *Registry) GetService(name string) (*Config, bool) <span class="cov0" title="0">{
        svc, ok := r.services[name]
        return svc, ok
}</span>

func (r *Registry) GetAllServices() []*Config <span class="cov0" title="0">{
        services := make([]*Config, 0, len(r.services))
        for _, svc := range r.services </span><span class="cov0" title="0">{
                services = append(services, svc)
        }</span>
        <span class="cov0" title="0">return services</span>
}

func (r *Registry) GetServiceByPath(path string) (*Config, bool) <span class="cov0" title="0">{
        for _, svc := range r.services </span><span class="cov0" title="0">{
                if path == svc.BasePath || (path != "/" &amp;&amp; svc.BasePath != "/" &amp;&amp;
                        (path == svc.BasePath || strings.HasPrefix(path, svc.BasePath+"/"))) </span><span class="cov0" title="0">{
                        return svc, true
                }</span>
        }
        <span class="cov0" title="0">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "strings"
        "time"
)

// HTTPClient is an interface for HTTP client implementations
type HTTPClient interface {
        Do(req *http.Request) (*http.Response, error)
}

// DefaultHTTPClient returns an http client with sensible defaults
func DefaultHTTPClient(timeout time.Duration) *http.Client <span class="cov0" title="0">{
        return &amp;http.Client{
                Timeout: timeout,
                Transport: &amp;http.Transport{
                        MaxIdleConns:        100,
                        MaxIdleConnsPerHost: 20,
                        IdleConnTimeout:     90 * time.Second,
                },
        }
}</span>

// ReadJSON reads JSON from a request body
func ReadJSON(body io.ReadCloser, target interface{}) error <span class="cov0" title="0">{
        defer body.Close()
        return json.NewDecoder(body).Decode(target)
}</span>

// WriteJSON writes JSON to response
func WriteJSON(w http.ResponseWriter, status int, data interface{}) error <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        return json.NewEncoder(w).Encode(data)
}</span>

// IsJSON checks if a byte slice is valid JSON
func IsJSON(data []byte) bool <span class="cov0" title="0">{
        return json.Valid(data)
}</span>

// BuildURL builds a URL from a base URL and path segments
func BuildURL(baseURL string, pathSegments ...string) string <span class="cov0" title="0">{
        base := strings.TrimRight(baseURL, "/")

        if len(pathSegments) == 0 </span><span class="cov0" title="0">{
                return base
        }</span>

        <span class="cov0" title="0">var path string
        for _, segment := range pathSegments </span><span class="cov0" title="0">{
                segment = strings.Trim(segment, "/")
                if segment != "" </span><span class="cov0" title="0">{
                        path += "/" + segment
                }</span>
        }

        <span class="cov0" title="0">return base + path</span>
}

// BuildQueryString builds a URL query string from a map
func BuildQueryString(params map[string]string) string <span class="cov0" title="0">{
        if len(params) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">query := "?"
        first := true
        for key, value := range params </span><span class="cov0" title="0">{
                if !first </span><span class="cov0" title="0">{
                        query += "&amp;"
                }</span>
                <span class="cov0" title="0">query += fmt.Sprintf("%s=%s", key, value)
                first = false</span>
        }

        <span class="cov0" title="0">return query</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package utils

import (
        "encoding/json"
        "fmt"
        "strconv"
        "strings"
)

// JSONPath extracts a value from JSON data using a simple JSONPath-like syntax
// Example: $.users[0].name
func JSONPath(data []byte, path string) (interface{}, error) <span class="cov0" title="0">{
        var result interface{}
        if err := json.Unmarshal(data, &amp;result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to unmarshal JSON: %w", err)
        }</span>

        // Remove $. prefix
        <span class="cov0" title="0">if strings.HasPrefix(path, "$.") </span><span class="cov0" title="0">{
                path = path[2:]
        }</span>

        // Split path components
        <span class="cov0" title="0">components := strings.Split(path, ".")

        for _, component := range components </span><span class="cov0" title="0">{
                // Handle array indexing
                if strings.Contains(component, "[") &amp;&amp; strings.Contains(component, "]") </span><span class="cov0" title="0">{
                        // Extract field name and index
                        parts := strings.Split(component, "[")
                        fieldName := parts[0]
                        indexPart := strings.TrimSuffix(parts[1], "]")

                        // Get the map at field name
                        mapObj, ok := result.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("expected object for field access '%s', got %T", fieldName, result)
                        }</span>

                        <span class="cov0" title="0">arrayValue, exists := mapObj[fieldName]
                        if !exists </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("field '%s' not found", fieldName)
                        }</span>

                        // Parse array index
                        <span class="cov0" title="0">index, err := strconv.Atoi(indexPart)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid array index '%s': %w", indexPart, err)
                        }</span>

                        // Access array element
                        <span class="cov0" title="0">array, ok := arrayValue.([]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("expected array for field '%s', got %T", fieldName, arrayValue)
                        }</span>

                        <span class="cov0" title="0">if index &lt; 0 || index &gt;= len(array) </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("array index out of bounds: %d (array length: %d)", index, len(array))
                        }</span>

                        <span class="cov0" title="0">result = array[index]</span>
                } else<span class="cov0" title="0"> {
                        // Regular object property access
                        mapObj, ok := result.(map[string]interface{})
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("expected object at path '%s', got %T", component, result)
                        }</span>

                        <span class="cov0" title="0">result, ok = mapObj[component]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("field '%s' not found", component)
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}

// SetJSONPath sets a value at a specific path in a JSON object
func SetJSONPath(data map[string]interface{}, path string, value interface{}) error <span class="cov0" title="0">{
        if strings.HasPrefix(path, "$.") </span><span class="cov0" title="0">{
                path = path[2:]
        }</span>

        <span class="cov0" title="0">components := strings.Split(path, ".")
        current := data

        for i, component := range components </span><span class="cov0" title="0">{
                if i == len(components)-1 </span><span class="cov0" title="0">{
                        // Last component, set the value
                        current[component] = value
                        return nil
                }</span>

                // Navigate or create intermediate objects
                <span class="cov0" title="0">if next, exists := current[component]; exists </span><span class="cov0" title="0">{
                        if nextMap, ok := next.(map[string]interface{}); ok </span><span class="cov0" title="0">{
                                current = nextMap
                        }</span> else<span class="cov0" title="0"> {
                                return fmt.Errorf("cannot set path: intermediate component '%s' is not an object", component)
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Create new object
                        newObj := make(map[string]interface{})
                        current[component] = newObj
                        current = newObj
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package websocket

import (
        "fmt"
        "net/http"
        "net/url"
        "sync"
        "time"

        "github.com/gorilla/websocket"
        "github.com/labstack/echo/v4"
        "github.com/sirupsen/logrus"
)

type Config struct {
        ReadBufferSize    int           `yaml:"readBufferSize"`
        WriteBufferSize   int           `yaml:"writeBufferSize"`
        HandshakeTimeout  time.Duration `yaml:"handshakeTimeout"`
        ReadTimeout       time.Duration `yaml:"readTimeout"`
        WriteTimeout      time.Duration `yaml:"writeTimeout"`
        PingPeriod        time.Duration `yaml:"pingPeriod"`
        MaxMessageSize    int64         `yaml:"maxMessageSize"`
        EnableCompression bool          `yaml:"enableCompression"`
}

type Proxy struct {
        config   Config
        logger   *logrus.Logger
        upgrader websocket.Upgrader
}

type Connection struct {
        clientConn *websocket.Conn
        serverConn *websocket.Conn
        proxy      *Proxy
        target     string
        done       chan struct{}
        once       sync.Once
}

func NewProxy(config Config, logger *logrus.Logger) *Proxy <span class="cov0" title="0">{
        if config.ReadBufferSize == 0 </span><span class="cov0" title="0">{
                config.ReadBufferSize = 4096
        }</span>
        <span class="cov0" title="0">if config.WriteBufferSize == 0 </span><span class="cov0" title="0">{
                config.WriteBufferSize = 4096
        }</span>
        <span class="cov0" title="0">if config.HandshakeTimeout == 0 </span><span class="cov0" title="0">{
                config.HandshakeTimeout = 10 * time.Second
        }</span>
        <span class="cov0" title="0">if config.ReadTimeout == 0 </span><span class="cov0" title="0">{
                config.ReadTimeout = 60 * time.Second
        }</span>
        <span class="cov0" title="0">if config.WriteTimeout == 0 </span><span class="cov0" title="0">{
                config.WriteTimeout = 10 * time.Second
        }</span>
        <span class="cov0" title="0">if config.PingPeriod == 0 </span><span class="cov0" title="0">{
                config.PingPeriod = 54 * time.Second
        }</span>
        <span class="cov0" title="0">if config.MaxMessageSize == 0 </span><span class="cov0" title="0">{
                config.MaxMessageSize = 512 * 1024
        }</span>

        <span class="cov0" title="0">upgrader := websocket.Upgrader{
                ReadBufferSize:   config.ReadBufferSize,
                WriteBufferSize:  config.WriteBufferSize,
                HandshakeTimeout: config.HandshakeTimeout,
                CheckOrigin: func(r *http.Request) bool </span><span class="cov0" title="0">{
                        return true
                }</span>,
                EnableCompression: config.EnableCompression,
        }

        <span class="cov0" title="0">return &amp;Proxy{
                config:   config,
                logger:   logger,
                upgrader: upgrader,
        }</span>
}

func (p *Proxy) ProxyWebSocket(c echo.Context, targetURL string) error <span class="cov0" title="0">{
        clientConn, err := p.upgrader.Upgrade(c.Response(), c.Request(), nil)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.WithError(err).Error("Failed to upgrade client connection")
                return err
        }</span>

        <span class="cov0" title="0">target, err := url.Parse(targetURL)
        if err != nil </span><span class="cov0" title="0">{
                clientConn.Close()
                return err
        }</span>

        <span class="cov0" title="0">wsScheme := "ws"
        if target.Scheme == "https" </span><span class="cov0" title="0">{
                wsScheme = "wss"
        }</span>

        <span class="cov0" title="0">wsURL := fmt.Sprintf("%s://%s%s", wsScheme, target.Host, target.Path)
        if target.RawQuery != "" </span><span class="cov0" title="0">{
                wsURL += "?" + target.RawQuery
        }</span>

        <span class="cov0" title="0">dialer := websocket.Dialer{
                HandshakeTimeout: p.config.HandshakeTimeout,
        }

        serverConn, _, err := dialer.Dial(wsURL, nil)
        if err != nil </span><span class="cov0" title="0">{
                p.logger.WithError(err).WithField("target", wsURL).Error("Failed to connect to target WebSocket")
                clientConn.Close()
                return err
        }</span>

        <span class="cov0" title="0">conn := &amp;Connection{
                clientConn: clientConn,
                serverConn: serverConn,
                proxy:      p,
                target:     wsURL,
                done:       make(chan struct{}),
        }

        go conn.proxyClientToServer()
        go conn.proxyServerToClient()

        &lt;-conn.done

        return nil</span>
}

func (c *Connection) proxyClientToServer() <span class="cov0" title="0">{
        defer c.close()

        if err := c.clientConn.SetReadDeadline(time.Now().Add(c.proxy.config.ReadTimeout)); err != nil </span><span class="cov0" title="0">{
                c.proxy.logger.WithError(err).Error("Failed to set read deadline on client connection")
                return
        }</span>

        <span class="cov0" title="0">c.clientConn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                if err := c.clientConn.SetReadDeadline(time.Now().Add(c.proxy.config.ReadTimeout)); err != nil </span><span class="cov0" title="0">{
                        c.proxy.logger.WithError(err).Error("Failed to set read deadline in pong handler")
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                messageType, data, err := c.clientConn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                c.proxy.logger.WithError(err).Error("Unexpected WebSocket close error from client")
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">if int64(len(data)) &gt; c.proxy.config.MaxMessageSize </span><span class="cov0" title="0">{
                        c.proxy.logger.Error("Message size exceeds maximum allowed size")
                        break</span>
                }

                <span class="cov0" title="0">if err := c.serverConn.SetWriteDeadline(time.Now().Add(c.proxy.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                        c.proxy.logger.WithError(err).Error("Failed to set write deadline on server connection")
                        break</span>
                }

                <span class="cov0" title="0">if err := c.serverConn.WriteMessage(messageType, data); err != nil </span><span class="cov0" title="0">{
                        c.proxy.logger.WithError(err).Error("Failed to write message to server")
                        break</span>
                }
        }
}

func (c *Connection) proxyServerToClient() <span class="cov0" title="0">{
        defer c.close()

        if err := c.serverConn.SetReadDeadline(time.Now().Add(c.proxy.config.ReadTimeout)); err != nil </span><span class="cov0" title="0">{
                c.proxy.logger.WithError(err).Error("Failed to set read deadline on server connection")
                return
        }</span>

        <span class="cov0" title="0">c.serverConn.SetPongHandler(func(string) error </span><span class="cov0" title="0">{
                if err := c.serverConn.SetReadDeadline(time.Now().Add(c.proxy.config.ReadTimeout)); err != nil </span><span class="cov0" title="0">{
                        c.proxy.logger.WithError(err).Error("Failed to set read deadline in pong handler")
                }</span>
                <span class="cov0" title="0">return nil</span>
        })

        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                messageType, data, err := c.serverConn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{
                        if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) </span><span class="cov0" title="0">{
                                c.proxy.logger.WithError(err).Error("Unexpected WebSocket close error from server")
                        }</span>
                        <span class="cov0" title="0">break</span>
                }

                <span class="cov0" title="0">if int64(len(data)) &gt; c.proxy.config.MaxMessageSize </span><span class="cov0" title="0">{
                        c.proxy.logger.Error("Message size exceeds maximum allowed size")
                        break</span>
                }

                <span class="cov0" title="0">if err := c.clientConn.SetWriteDeadline(time.Now().Add(c.proxy.config.WriteTimeout)); err != nil </span><span class="cov0" title="0">{
                        c.proxy.logger.WithError(err).Error("Failed to set write deadline on client connection")
                        break</span>
                }

                <span class="cov0" title="0">if err := c.clientConn.WriteMessage(messageType, data); err != nil </span><span class="cov0" title="0">{
                        c.proxy.logger.WithError(err).Error("Failed to write message to client")
                        break</span>
                }
        }
}

func (c *Connection) close() <span class="cov0" title="0">{
        c.once.Do(func() </span><span class="cov0" title="0">{
                if err := c.clientConn.Close(); err != nil </span><span class="cov0" title="0">{
                        c.proxy.logger.WithError(err).Debug("Error closing client connection")
                }</span>
                <span class="cov0" title="0">if err := c.serverConn.Close(); err != nil </span><span class="cov0" title="0">{
                        c.proxy.logger.WithError(err).Debug("Error closing server connection")
                }</span>
                <span class="cov0" title="0">close(c.done)</span>
        })
}

func (p *Proxy) HandleWebSocketUpgrade(c echo.Context) error <span class="cov0" title="0">{
        targetURL := c.Get("target_url").(string)
        return p.ProxyWebSocket(c, targetURL)
}</span>

func WebSocketMiddleware(proxy *Proxy) echo.MiddlewareFunc <span class="cov0" title="0">{
        return func(next echo.HandlerFunc) echo.HandlerFunc </span><span class="cov0" title="0">{
                return func(c echo.Context) error </span><span class="cov0" title="0">{
                        if isWebSocketUpgrade(c.Request()) </span><span class="cov0" title="0">{
                                targetURL := c.Get("target_url")
                                if targetURL == nil </span><span class="cov0" title="0">{
                                        return echo.NewHTTPError(http.StatusBadRequest, "No target URL specified for WebSocket")
                                }</span>
                                <span class="cov0" title="0">return proxy.ProxyWebSocket(c, targetURL.(string))</span>
                        }
                        <span class="cov0" title="0">return next(c)</span>
                }
        }
}

func isWebSocketUpgrade(r *http.Request) bool <span class="cov0" title="0">{
        return r.Header.Get("Connection") == "Upgrade" &amp;&amp; r.Header.Get("Upgrade") == "websocket"
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package main

import (
        "flag"
        "fmt"
        "log"
        "os"
        "path/filepath"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "gopkg.in/yaml.v3"
)

type TokenClaims struct {
        UserID   string `json:"user_id"`
        Username string `json:"username"`
        Role     string `json:"role"`
        jwt.RegisteredClaims
}

type AuthSecrets struct {
        JWTSecret string `yaml:"jwtSecret"`
}

func loadJWTSecret() (string, error) <span class="cov0" title="0">{
        currentDir, _ := os.Getwd()
        scriptDir := filepath.Join(currentDir, "auth")

        secretsPaths := []string{
                "auth_secrets.yaml",
                filepath.Join(scriptDir, "auth_secrets.yaml"),
                filepath.Join(currentDir, "auth_secrets.yaml"),
                filepath.Join(currentDir, "../config/auth_secrets.yaml"),
                filepath.Join(currentDir, "../../config/auth_secrets.yaml"),
        }

        fmt.Println("Current directory:", currentDir)

        for _, path := range secretsPaths </span><span class="cov0" title="0">{
                fmt.Printf("Checking for auth_secrets.yaml at: %s\n", path)

                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        data, err := os.ReadFile(path)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Found but couldn't read %s: %v\n", path, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">var secrets AuthSecrets
                        if err := yaml.Unmarshal(data, &amp;secrets); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Found but couldn't parse %s: %v\n", path, err)
                                continue</span>
                        }

                        <span class="cov0" title="0">if secrets.JWTSecret != "" </span><span class="cov0" title="0">{
                                return secrets.JWTSecret, nil
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf("Found %s but it doesn't contain a JWT secret\n", path)
                        }</span>
                }
        }

        <span class="cov0" title="0">if envSecret := os.Getenv("ODIN_JWT_SECRET"); envSecret != "" </span><span class="cov0" title="0">{
                fmt.Println("Using JWT secret from environment variable ODIN_JWT_SECRET")
                return envSecret, nil
        }</span>

        <span class="cov0" title="0">fmt.Println("\nERROR: Couldn't load JWT secret from any source")
        fmt.Println("Please create an auth_secrets.yaml file in the current directory with:")
        fmt.Println("jwtSecret: your-secret-here")
        fmt.Println("\nOR run with:")
        fmt.Println("go run auth/jwt-generator.go -secret=your-secret-here")

        return "", fmt.Errorf("couldn't load JWT secret from any source")</span>
}

func main() <span class="cov0" title="0">{
        secretFromFile, _ := loadJWTSecret()

        secret := flag.String("secret", secretFromFile, "JWT secret key (will use from config file if found)")
        userID := flag.String("userid", "usr-001", "User ID")
        username := flag.String("username", "john_doe", "Username")
        role := flag.String("role", "user", "User role")
        expiry := flag.Duration("expiry", time.Hour, "Token expiry duration")
        flag.Parse()

        if *secret == "" </span><span class="cov0" title="0">{
                log.Fatal("JWT secret is required. Provide it with -secret flag or in auth_secrets.yaml")
        }</span>

        <span class="cov0" title="0">claims := &amp;TokenClaims{
                UserID:   *userID,
                Username: *username,
                Role:     *role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(*expiry)),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

        tokenString, err := token.SignedString([]byte(*secret))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("Error generating token: %v", err)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Token: %s\n", tokenString)
        fmt.Printf("Authorization header: Bearer %s\n", tokenString)
        fmt.Printf("Expiry: %v\n", time.Now().Add(*expiry).Format(time.RFC3339))</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
